{
  "language": "Solidity",
  "sources": {
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IBn256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n// G1Point implements a point in G1 group.\nstruct G1Point {\n  uint256 x;\n  uint256 y;\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n\nimport { SortitionCredential } from \"./ISortition.sol\";\n\n/**\n * Fast updater interface.\n */\ninterface IFastUpdater {\n\n    /// Signature structure\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// Fast update structure\n    struct FastUpdates {\n        uint256 sortitionBlock;\n        SortitionCredential sortitionCredential;\n        bytes deltas;\n        Signature signature;\n    }\n\n    /// Event emitted when a new set of updates is submitted.\n    event FastUpdateFeedsSubmitted(\n        uint32 indexed votingRoundId,\n        address indexed signingPolicyAddress\n    );\n\n    /// Event emitted when a feed is added or reset.\n    event FastUpdateFeedReset(\n        uint256 indexed votingRoundId,\n        uint256 indexed index,\n        bytes21 indexed id,\n        uint256 value,\n        int8 decimals);\n\n    /// Event emitted when a feed is removed.\n    event FastUpdateFeedRemoved(\n        uint256 indexed index);\n\n    /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.\n    event FastUpdateFeeds(uint256 indexed votingEpochId, uint256[] feeds, int8[] decimals);\n\n    /**\n     * The entry point for providers to submit an update transaction.\n     * @param _updates Data of an update transaction, which in addition to the actual list of updates,\n     * includes the sortition credential proving the provider's eligibility to make updates in the also-included\n     * sortition round, as well as a signature allowing a single registered provider to submit from multiple\n     * EVM accounts.\n     */\n    function submitUpdates(FastUpdates calldata _updates) external;\n\n    /**\n     * Public access to the stored data of all feeds.\n     * @return _feedIds The list of feed ids.\n     * @return _feeds The list of feeds.\n     * @return _decimals The list of decimal places for feeds.\n     * @return _timestamp The timestamp of the last update.\n     */\n    function fetchAllCurrentFeeds()\n        external view\n        returns (\n            bytes21[] memory _feedIds,\n            uint256[] memory _feeds,\n            int8[] memory _decimals,\n            uint64 _timestamp\n        );\n\n    /**\n     * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.\n     * Feeds should be sorted for better performance.\n     * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in\n     * the `FastUpdatesConfiguration` contract.\n     * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given\n     * (which may not be their sorted order).\n     * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were\n     * given (which may not be their sorted order).\n     * @return _timestamp The timestamp of the last update.\n     */\n    function fetchCurrentFeeds(\n        uint256[] calldata _indices\n    )\n        external view\n        returns (\n            uint256[] memory _feeds,\n            int8[] memory _decimals,\n            uint64 _timestamp\n        );\n\n    /**\n     * Informational getter concerning the eligibility criterion for being chosen by sortition.\n     * @return _cutoff The upper endpoint of the acceptable range of \"scores\" that providers generate for sortition.\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\n     */\n    function currentScoreCutoff() external view returns (uint256 _cutoff);\n\n    /**\n     * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.\n     * @param _blockNum The block for which the cutoff is requested.\n     * @return _cutoff The upper endpoint of the acceptable range of \"scores\" that providers generate for sortition.\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\n     */\n    function blockScoreCutoff(uint256 _blockNum) external view returns (uint256 _cutoff);\n\n    /**\n     * Informational getter concerning a provider's likelihood of being chosen by sortition.\n     * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the\n     * sender of an update transaction, due to the signature included in the `FastUpdates` type.\n     * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's\n     * delegation weight for the FTSO, but rescaled against a fixed number of \"virtual providers\", indicating how many\n     * potential updates a single provider may make in a sortition round.\n     */\n    function currentSortitionWeight(address _signingPolicyAddress) external view returns (uint256 _weight);\n\n    /**\n     * The submission window is a number of blocks forming a \"grace period\" after a round of sortition starts,\n     * during which providers may submit updates for that round. In other words, each block starts a new round of\n     * sortition and that round lasts `submissionWindow` blocks.\n     */\n    function submissionWindow() external view returns (uint8);\n\n    /**\n     * Id of the current reward epoch.\n     */\n    function currentRewardEpochId() external view returns (uint24);\n\n    /**\n     * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).\n     * @param _historySize The number of blocks for which the number of updates should be returned.\n     * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.\n     * The array is ordered from the current block to the oldest block.\n     */\n    function numberOfUpdates(uint256 _historySize) external view returns (uint256[] memory _noOfUpdates);\n\n    /**\n     * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.\n     * @param _blockNumber The block number for which the number of updates should be returned.\n     * @return _noOfUpdates The number of updates submitted in the specified block.\n     */\n    function numberOfUpdatesInBlock(uint256 _blockNumber) external view returns (uint256 _noOfUpdates);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdatesConfiguration.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * FastUpdatesConfiguration interface.\n */\ninterface IFastUpdatesConfiguration {\n\n    /**\n     * The feed configuration struct.\n     */\n    struct FeedConfiguration {\n        // feed id\n        bytes21 feedId;\n        // reward band value (interpreted off-chain) in relation to the median\n        uint32 rewardBandValue;\n        // inflation share\n        uint24 inflationShare;\n    }\n\n    /// Event emitted when a feed is added.\n    event FeedAdded(bytes21 indexed feedId, uint32 rewardBandValue, uint24 inflationShare, uint256 index);\n    /// Event emitted when a feed is updated.\n    event FeedUpdated(bytes21 indexed feedId, uint32 rewardBandValue, uint24 inflationShare, uint256 index);\n    /// Event emitted when a feed is removed.\n    event FeedRemoved(bytes21 indexed feedId, uint256 index);\n\n    /**\n     * Returns the index of a feed.\n     * @param _feedId The feed id.\n     * @return _index The index of the feed.\n     */\n    function getFeedIndex(bytes21 _feedId) external view returns (uint256 _index);\n\n    /**\n     * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).\n     * @param _index The index.\n     * @return _feedId The feed id.\n     */\n    function getFeedId(uint256 _index) external view returns (bytes21 _feedId);\n\n    /**\n     * Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).\n     */\n    function getFeedIds() external view returns (bytes21[] memory);\n\n    /**\n     * Returns the number of feeds, including removed ones.\n     */\n    function getNumberOfFeeds() external view returns (uint256);\n\n    /**\n     * Returns the feed configurations, including removed ones.\n     */\n    function getFeedConfigurations() external view returns (FeedConfiguration[] memory);\n\n    /**\n     * Returns the unused indices - indices of removed feeds.\n     */\n    function getUnusedIndices() external view returns (uint256[] memory);\n}"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/ISortition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {G1Point} from \"./IBn256.sol\";\n\nstruct SortitionCredential {\n  uint256 replicate;\n  G1Point gamma;\n  uint256 c;\n  uint256 s;\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\ninterface IFlareContractRegistry {\n    /**\n     * @notice Returns contract address for the given name - might be address(0)\n     * @param _name             name of the contract\n     */\n    function getContractAddressByName(string calldata _name) external view returns(address);\n\n    /**\n     * @notice Returns contract address for the given name hash - might be address(0)\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\n     */\n    function getContractAddressByHash(bytes32 _nameHash) external view returns(address);\n\n    /**\n     * @notice Returns contract addresses for the given names - might be address(0)\n     * @param _names            names of the contracts\n     */\n    function getContractAddressesByName(string[] calldata _names) external view returns(address[] memory);\n\n    /**\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\n     */\n    function getContractAddressesByHash(bytes32[] calldata _nameHashes) external view returns(address[] memory);\n\n    /**\n     * @notice Returns all contract names and corresponding addresses\n     */\n    function getAllContracts() external view returns(string[] memory _names, address[] memory _addresses);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/ChronicleDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IChronicle.sol\";\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\n\ninterface ISelfKisser {\n\t/// @notice Kisses caller on oracle `oracle`.\n\tfunction selfKiss(address oracle) external;\n}\n\ncontract ChronicleDataProvider is IDataProvider {\n\t/// @notice The token to read data for.\n\taddress public token;\n\t/// @notice The Chronicle oracle to read from.\n\tIChronicle public chronicle =\n\t\tIChronicle(address(0xdd6D76262Fd7BdDe428dcfCd94386EbAe0151603));\n\t/// @notice The chain ID of the network.\n\tuint32 public chainId;\n\n\t/// @notice The SelfKisser granting access to Chronicle oracles.\n\tISelfKisser public selfKisser =\n\t\tISelfKisser(address(0x0Dcc19657007713483A5cA76e6A7bbe5f56EA37d));\n\n\tconstructor(address _token, uint32 _chainId) {\n\t\t// Note to add address(this) to chronicle oracle's whitelist.\n\t\t// This allows the contract to read from the chronicle oracle.\n\t\tselfKisser.selfKiss(address(chronicle));\n\t\tchainId = _chainId;\n\t\ttoken = _token;\n\t}\n\n\t/// @notice Function to read the latest data from the Chronicle oracle.\n\t/// @return val The current value returned by the oracle.\n\t/// @return age The timestamp of the last update from the oracle.\n\tfunction read() external view returns (uint256 val, uint256 age) {\n\t\t(val, age) = chronicle.readWithAge();\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn string(abi.encodePacked(\"priceChronicle\", IERC20(token).name()));\n\t}\n\n\tfunction getMetricData(\n\t) external view override returns (uint256) {\n\t\t(uint256 val, ) = chronicle.readWithAge();\n\t\treturn val;\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\t(, uint256 age) = chronicle.readWithAge();\n\t\treturn age;\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"partner\";\n\t\ttags[1] = \"chronicle\";\n\t\ttags[2] = \"price\";\n\t\ttags[3] = IERC20(token).name();\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.PRICE;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\n\tfunction getChainId() external view override returns (uint32) {\n\t\treturn chainId;\n\t}\n\n}\n"
    },
    "contracts/DataAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OApp, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LiquidityManager } from \"./LiquidityManager.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport { IFlareContractRegistry } from \"@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport { IFastUpdater } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol\";\nimport { IDataProvider, Data, DataTypes } from \"./IDataProvider.sol\";\n\nuint32 constant CALLBACK_GAS_LIMIT = 4_000_000;\n\nstruct TokenInfo {\n\tstring _name;\n\taddress _address;\n\tuint32 _chainId;\n\tuint32 _id;\n}\n\nstruct IndexUpdateMessage {\n\tData[] liquidityMessages;\n\tData[] supplyMessages;\n\tData[] priceMessages;\n}\n\nstruct AggregatorParams {\n\tuint256 _timeWindow;\n\tuint256 _sampleSize;\n\tuint256 _bribeUnit;\n}\n\nerror NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\n\ncontract DataAggregator is OApp {\n\tTokenInfo[] public tokenInfo;\n\tIDataProvider[] public dataProviders;\n\tTokenInfo[] tmpTokens;\n\tmapping(string => uint256) public tokens;\n\tstring[] public tokenSymbols;\n\n\tuint256[] public totalSupplies;\n\tuint256[] public liquidities;\n\tuint256[] public prices;\n\tuint256[] public tokenParamsTimestampUpdates;\n\n\tData[] public messages;\n\n\tmapping(uint256 => uint256[]) public movingAverage;\n\tuint256 sampleSize;\n\tuint256 timeWindow;\n\tuint256 samplingFrequency;\n\tuint256 lastSampleTime;\n\tuint256[] public lastIndexOrder;\n\tmapping(string => uint256[]) public tagsIndexOrder;\n\tmapping(string => uint256) public tagsIndexTimestamp;\n\tuint256 public lastIndexTimestamp;\n\tuint256 public bribeUnit;\n\tuint32 public chainId;\n\tuint32 public mainChainId;\n\n\tconstructor(\n\t\tTokenInfo[] memory _tokenInfo,\n\t\taddress _endpoint,\n\t\taddress[] memory _dataProviders,\n\t\tAggregatorParams memory _aggregatorParams\n\t) OApp(_endpoint, msg.sender) {\n\t\tsampleSize = _aggregatorParams._sampleSize;\n\t\ttimeWindow = _aggregatorParams._timeWindow;\n\t\tsamplingFrequency = timeWindow / sampleSize;\n\t\tbribeUnit = _aggregatorParams._bribeUnit;\n\n\t\tfor (uint256 i = 0; i < _dataProviders.length; i++) {\n\t\t\tdataProviders.push(IDataProvider(_dataProviders[i]));\n\t\t}\n\n\t\tfor (uint256 i = 0; i < _tokenInfo.length; i++) {\n\t\t\ttokenInfo.push(_tokenInfo[i]);\n\t\t\t// tokenSymbols.push(_tokenInfo[i]._symbol);\n\t\t\ttokens[_tokenInfo[i]._name] = _tokenInfo[i]._id;\n\t\t}\n\n\t\tprices = new uint256[](tokenInfo.length);\n\t\ttotalSupplies = new uint256[](tokenInfo.length);\n\t\tliquidities = new uint256[](tokenInfo.length);\n\t\ttokenParamsTimestampUpdates = new uint256[](tokenInfo.length);\n\t}\n\n\tfunction isMainChain() public view returns (bool) {\n\t\treturn chainId == mainChainId;\n\t}\n\n\tfunction isOnSameChain(uint32 _chainId) public view returns (bool) {\n\t\treturn chainId == _chainId;\n\t}\n\n\tfunction setChainId(uint32 _chainId, uint32 _mainChainId) external {\n\t\tchainId = _chainId;\n\t\tmainChainId = _mainChainId;\n\t}\n\n\tfunction updateTokenParams(\n\t\tuint256[] memory _totalSupplies,\n\t\tuint256[] memory _liquidities\n\t) external {\n\t\tfor (uint256 i = 0; i < dataProviders.length; i++) {\n\t\t\tDataTypes dataType = dataProviders[i].getDataType();\n\t\t\tif (dataType == DataTypes.PRICE) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\tprices[tokens[dataProviders[i].getLabel()]] = dataProviders[\n\t\t\t\t\t\ti\n\t\t\t\t\t].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dataType == DataTypes.TOTAL_SUPPLY) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\ttotalSupplies[\n\t\t\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t\t\t] = dataProviders[i].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dataType == DataTypes.LIQUIDITY) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\tliquidities[\n\t\t\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t\t\t] = dataProviders[i].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokenParamsTimestampUpdates[\n\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t] = dataProviders[i].getDataTimestamp();\n\t\t}\n\n\t\t// DATA MESSAGES\n\t\tif (isMainChain()) {\n\t\t\tfor (uint256 i = 0; i < messages.length; i++) {\n\t\t\t\tif (messages[i].dataType == DataTypes.PRICE) {\n\t\t\t\t\tprices[tokens[messages[i].label]] = messages[i].metricData;\n\t\t\t\t}\n\t\t\t\tif (messages[i].dataType == DataTypes.TOTAL_SUPPLY) {\n\t\t\t\t\ttotalSupplies[tokens[messages[i].label]] = messages[i]\n\t\t\t\t\t\t.metricData;\n\t\t\t\t}\n\t\t\t\tif (messages[i].dataType == DataTypes.LIQUIDITY) {\n\t\t\t\t\tliquidities[tokens[messages[i].label]] = messages[i]\n\t\t\t\t\t\t.metricData;\n\t\t\t\t}\n\t\t\t\ttokenParamsTimestampUpdates.push(messages[i].dataTimestamp);\n\t\t\t}\n\t\t}\n\n\t\tif (!isMainChain()) {\n\t\t\tData[] memory _supplyMessages = new Data[](tokenInfo.length);\n\t\t\tData[] memory _liquidityMessages = new Data[](tokenInfo.length);\n\n\t\t\tData[] memory _priceMessages = new Data[](tokenInfo.length);\n\n\t\t\tfor (uint256 i = 0; i < tokenInfo.length; i++) {\n\t\t\t\tif (chainId == tokenInfo[i]._chainId) {\n\t\t\t\t\t_supplyMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\t_totalSupplies[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.TOTAL_SUPPLY,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t\t_liquidityMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\t_liquidities[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.LIQUIDITY,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t\t_priceMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\tprices[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.PRICE,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _lzReceive(\n\t\tOrigin calldata /*_origin*/,\n\t\tbytes32 /*_guid*/,\n\t\tbytes calldata payload,\n\t\taddress /*_executor*/,\n\t\tbytes calldata /*_extraData*/\n\t) internal override {\n\t\t// data = abi.decode(payload, (string));\n\t\tData[] memory inboxMessages = abi.decode(payload, (Data[]));\n\t\tfor (uint256 i = 0; i < inboxMessages.length; i++) {\n\t\t\tmessages.push(inboxMessages[i]);\n\t\t}\n\t}\n\n\tfunction normalizePrice(\n\t\tuint256 price,\n\t\tint8 decimals\n\t) public pure returns (uint256) {\n\t\tint8 maxDecimals = 18; // Set maximum decimals to 10\n\n\t\t// Scale the price to the maximum number of decimals\n\t\tuint256 normalizedPrice = price *\n\t\t\t(10 ** uint256(uint8(maxDecimals - decimals)));\n\n\t\treturn normalizedPrice;\n\t}\n\n\tfunction quote(\n\t\tuint32 _dstEid,\n\t\tstring memory _message,\n\t\tbytes memory _options,\n\t\tbool _payInLzToken\n\t) public view returns (MessagingFee memory fee) {\n\t\tbytes memory payload = abi.encode(_message);\n\t\tfee = _quote(_dstEid, payload, _options, _payInLzToken);\n\t}\n\n\tfunction send(\n\t\tuint32 _dstEid,\n\t\tbytes memory _options,\n\t\tIndexUpdateMessage memory data\n\t) external payable returns (MessagingReceipt memory receipt) {\n\t\tbytes memory _payload = abi.encode(data);\n\t\treceipt = _lzSend(\n\t\t\t_dstEid,\n\t\t\t_payload,\n\t\t\t_options,\n\t\t\tMessagingFee(msg.value, 0),\n\t\t\tpayable(msg.sender)\n\t\t);\n\t}\n}\n"
    },
    "contracts/FtsoV2FeedConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IFlareContractRegistry } from \"@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport { IFastUpdater } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol\";\nimport { IFastUpdatesConfiguration } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdatesConfiguration.sol\";\n\nlibrary FTSOFeedIdConverter {\n\tfunction FeedCategoryCrypto() internal pure returns (uint8) {\n\t\treturn 1;\n\t}\n\n\tfunction getFeedId(\n\t\tuint8 _category,\n\t\tstring memory _name\n\t) internal pure returns (bytes21) {\n\t\tbytes memory nameBytes = bytes(_name);\n\t\trequire(nameBytes.length <= 20, \"name too long\");\n\t\treturn bytes21(bytes.concat(bytes1(_category), nameBytes));\n\t}\n\n\tfunction getCryptoFeedId(\n\t\tstring memory _name\n\t) internal pure returns (bytes21) {\n\t\treturn\n\t\t\tbytes21(bytes.concat(bytes1(FeedCategoryCrypto()), bytes(_name)));\n\t}\n\n\tfunction getFeedCategoryAndName(\n\t\tbytes21 _feedId\n\t) internal pure returns (uint8 _category, string memory _name) {\n\t\t_category = uint8(_feedId[0]);\n\t\tuint256 length = 20;\n\t\twhile (length > 0) {\n\t\t\tif (_feedId[length] != 0x00) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlength--;\n\t\t}\n\t\tbytes memory nameBytes = new bytes(length);\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tnameBytes[i] = _feedId[i + 1];\n\t\t}\n\t\t_name = string(nameBytes);\n\t}\n}\n\ncontract FtsoV2FeedConsumer {\n\tIFlareContractRegistry internal contractRegistry;\n\tIFastUpdater internal ftsoV2;\n    IFastUpdatesConfiguration internal fastUpdatesConfiguration;\n\tuint256[] public feedIndexes = [0, 2, 9];\n\n\tconstructor() {\n\t\tcontractRegistry = IFlareContractRegistry(\n\t\t\t0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\n\t\t);\n\t\tftsoV2 = IFastUpdater(\n\t\t\tcontractRegistry.getContractAddressByName(\"FastUpdater\")\n\t\t);\n\t}\n\n\n\n\t/**\n\t * Get the current value of the feeds.\n\t */\n\tfunction getFtsoV2CurrentFeedValues()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256[] memory _feedValues,\n\t\t\tint8[] memory _decimals,\n\t\t\tuint64 _timestamp\n\t\t)\n\t{\n\t\t(\n\t\t\tuint256[] memory feedValues,\n\t\t\tint8[] memory decimals,\n\t\t\tuint64 timestamp\n\t\t) = ftsoV2.fetchCurrentFeeds(feedIndexes);\n\t\t/* Your custom feed consumption logic. In this example the values are just returned. */\n\t\treturn (feedValues, decimals, timestamp);\n\t}\n\n\tfunction getFtsoV2CurrentFeedValuesByName(\n\t\tstring[] memory _assetName\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256[] memory _feedValues,\n\t\t\tint8[] memory _decimals,\n\t\t\tuint64 _timestamp\n\t\t)\n\t{\n\t\tbytes21[] memory feedIds = new bytes21[](_assetName.length);\n\t\tfor (uint256 i = 0; i < _assetName.length; i++) {\n\t\t\tfeedIds[i] = FTSOFeedIdConverter.getCryptoFeedId(\n\t\t\t\tstring.concat(string(_assetName[i]), string(\"/USD\"))\n\t\t\t);\n\t\t}\n\t\tuint256[] memory indices = new uint256[](feedIds.length);\n\t\tfor (uint256 i = 0; i < feedIds.length; i++) {\n\t\t\tindices[i] = fastUpdatesConfiguration.getFeedIndex(feedIds[i]);\n\t\t}\n\t\t(\n\t\t\tuint256[] memory feedValues,\n\t\t\tint8[] memory decimals,\n\t\t\tuint64 timestamp\n\t\t) = ftsoV2.fetchCurrentFeeds(indices);\n\t\t/* Your custom feed consumption logic. In this example the values are just returned. */\n\t\treturn (feedValues, decimals, timestamp);\n\t}\n\n\tfunction getFtsoV2CurrentFeedValuesByName(\n\t\tstring memory _assetName\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256[] memory _feedValues,\n\t\t\tint8[] memory _decimals,\n\t\t\tuint64 _timestamp\n\t\t)\n\t{\n\t\tbytes21[] memory feedIds = new bytes21[](1);\n\n\t\tfeedIds[0] = FTSOFeedIdConverter.getCryptoFeedId(\n\t\t\tstring.concat(string(_assetName), string(\"/USD\"))\n\t\t);\n\n\t\tuint256[] memory indices = new uint256[](feedIds.length);\n\t\tfor (uint256 i = 0; i < feedIds.length; i++) {\n\t\t\tindices[i] = fastUpdatesConfiguration.getFeedIndex(feedIds[i]);\n\t\t}\n\t\t(\n\t\t\tuint256[] memory feedValues,\n\t\t\tint8[] memory decimals,\n\t\t\tuint64 timestamp\n\t\t) = ftsoV2.fetchCurrentFeeds(indices);\n\t\t/* Your custom feed consumption logic. In this example the values are just returned. */\n\t\treturn (feedValues, decimals, timestamp);\n\t}\n}\n"
    },
    "contracts/FtsoV2FeedConsumerLz.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport { IFlareContractRegistry } from \"@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport { IFastUpdater } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol\";\nimport { OApp, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\n\n/**\n * THIS IS AN EXAMPLE CONTRACT.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\ncontract FtsoV2FeedConsumerLz is OApp {\n\tIFlareContractRegistry internal contractRegistry;\n\tIFastUpdater internal ftsoV2;\n\t// Feed indexes: 0 = FLR/USD, 2 = BTC/USD, 9 = ETH/USD\n\tuint256[] public feedIndexes = [0, 2, 9];\n\tstring public data = \"Nothing received yet.\";\n\n\t/**\n\t * Constructor initializes the FTSOv2 contract.\n\t * The contract registry is used to fetch the FTSOv2 contract address.\n\t */\n\tconstructor(\n\t\taddress _endpoint,\n\t\taddress _delegate\n\t) OApp(_endpoint, _delegate) {\n\t\tcontractRegistry = IFlareContractRegistry(\n\t\t\t0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\n\t\t);\n\t\tftsoV2 = IFastUpdater(\n\t\t\tcontractRegistry.getContractAddressByName(\"FastUpdater\")\n\t\t);\n\t}\n\n\t/**\n\t * Get the current value of the feeds.\n\t */\n\tfunction getFtsoV2CurrentFeedValues()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256[] memory _feedValues,\n\t\t\tint8[] memory _decimals,\n\t\t\tuint64 _timestamp\n\t\t)\n\t{\n\t\t(\n\t\t\tuint256[] memory feedValues,\n\t\t\tint8[] memory decimals,\n\t\t\tuint64 timestamp\n\t\t) = ftsoV2.fetchCurrentFeeds(feedIndexes);\n\t\t/* Your custom feed consumption logic. In this example the values are just returned. */\n\t\treturn (feedValues, decimals, timestamp);\n\t}\n\n\t/**\n\t * @notice Sends a message from the source chain to a destination chain.\n\t * @param _dstEid The endpoint ID of the destination chain.\n\t * @param _message The message string to be sent.\n\t * @param _options Additional options for message execution.\n\t * @dev Encodes the message as bytes and sends it using the `_lzSend` internal function.\n\t * @return receipt A `MessagingReceipt` struct containing details of the message sent.\n\t */\n\tfunction send(\n\t\tuint32 _dstEid,\n\t\tstring memory _message,\n\t\tbytes calldata _options\n\t) external payable returns (MessagingReceipt memory receipt) {\n\t\tbytes memory _payload = abi.encode(_message);\n\t\treceipt = _lzSend(\n\t\t\t_dstEid,\n\t\t\t_payload,\n\t\t\t_options,\n\t\t\tMessagingFee(msg.value, 0),\n\t\t\tpayable(msg.sender)\n\t\t);\n\t}\n\n\t/**\n\t * @notice Quotes the gas needed to pay for the full omnichain transaction in native gas or ZRO token.\n\t * @param _dstEid Destination chain's endpoint ID.\n\t * @param _message The message.\n\t * @param _options Message execution options (e.g., for sending gas to destination).\n\t * @param _payInLzToken Whether to return fee in ZRO token.\n\t * @return fee A `MessagingFee` struct containing the calculated gas fee in either the native token or ZRO token.\n\t */\n\tfunction quote(\n\t\tuint32 _dstEid,\n\t\tstring memory _message,\n\t\tbytes memory _options,\n\t\tbool _payInLzToken\n\t) public view returns (MessagingFee memory fee) {\n\t\tbytes memory payload = abi.encode(_message);\n\t\tfee = _quote(_dstEid, payload, _options, _payInLzToken);\n\t}\n\n\t/**\n\t * @dev Internal function override to handle incoming messages from another chain.\n\t * @dev _origin A struct containing information about the message sender.\n\t * @dev _guid A unique global packet identifier for the message.\n\t * @param payload The encoded message payload being received.\n\t *\n\t * @dev The following params are unused in the current implementation of the OApp.\n\t * @dev _executor The address of the Executor responsible for processing the message.\n\t * @dev _extraData Arbitrary data appended by the Executor to the message.\n\t *\n\t * Decodes the received payload and processes it as per the business logic defined in the function.\n\t */\n\tfunction _lzReceive(\n\t\tOrigin calldata /*_origin*/,\n\t\tbytes32 /*_guid*/,\n\t\tbytes calldata payload,\n\t\taddress /*_executor*/,\n\t\tbytes calldata /*_extraData*/\n\t) internal override {\n\t\tdata = abi.decode(payload, (string));\n\t}\n}\n"
    },
    "contracts/FTSOv2Provider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IChronicle.sol\";\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\nimport { IFlareContractRegistry } from \"@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport { IFastUpdater } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol\";\n\ncontract FTSOv2DataProvider is IDataProvider {\n\t/// @notice The token to read data for.\n\taddress public token;\n\tIFlareContractRegistry internal contractRegistry;\n\tIFastUpdater internal ftsoV2;\n\tuint256[] public feedIndexes;\n\tuint32 internal chainId;\n\n\tconstructor(address _token, uint256[] memory _feedIndex, uint32 _chainId) {\n\t\t// Flare FTSOv2 configuration\n\t\tcontractRegistry = IFlareContractRegistry(\n\t\t\t0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019\n\t\t);\n\t\tftsoV2 = IFastUpdater(\n\t\t\tcontractRegistry.getContractAddressByName(\"FastUpdater\")\n\t\t);\n\t\ttoken = _token;\n\t\tfeedIndexes = _feedIndex;\n\t\tchainId = _chainId;\n\t}\n\n\tfunction getFtsoV2CurrentFeedValues()\n\t\tpublic\n\t\tview\n\t\treturns (\n\t\t\tuint256[] memory _feedValues,\n\t\t\tint8[] memory _decimals,\n\t\t\tuint64 _timestamp\n\t\t)\n\t{\n\t\t(\n\t\t\tuint256[] memory feedValues,\n\t\t\tint8[] memory decimals,\n\t\t\tuint64 timestamp\n\t\t) = ftsoV2.fetchCurrentFeeds(feedIndexes);\n\t\t/* Your custom feed consumption logic. In this example the values are just returned. */\n\t\treturn (feedValues, decimals, timestamp);\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn string(abi.encodePacked(\"priceFTSOv2\", IERC20(token).name()));\n\t}\n\n\tfunction getMetricData(\n\t) external view override returns (uint256) {\n\t\t(uint256[] memory feedValues, , ) = getFtsoV2CurrentFeedValues();\n\t\treturn feedValues[0];\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\t(, , uint64 timestamp) = ftsoV2.fetchCurrentFeeds(feedIndexes);\n\t\treturn timestamp;\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"partner\";\n\t\ttags[1] = \"chronicle\";\n\t\ttags[2] = \"price\";\n\t\ttags[3] = IERC20(token).name();\n\t\treturn tags;\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.PRICE;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\t\n\tfunction getChainId() external view override returns (uint32) {\n\treturn chainId; \n\t}\n}\n"
    },
    "contracts/Hooks/BaseHook.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {IPoolManager, BalanceDelta} from \"../Uniswap/V4-Core/interfaces/IPoolManager.sol\";\nimport {IHooks} from \"../Uniswap/V4-Core/interfaces/IHooks.sol\";\nimport {PoolKey} from \"../Uniswap/V4-Core/types/PoolId.sol\";\nimport {Hooks} from \"../Uniswap/V4-Core/libraries/Hooks.sol\";\n\nabstract contract BaseHook is IHooks {\n    error NotPoolManager();\n    error NotSelf();\n    error InvalidPool();\n    error LockFailure();\n    error HookNotImplemented();\n\n    /// @notice The address of the pool manager\n    IPoolManager public immutable poolManager;\n\n    constructor(IPoolManager _poolManager) {\n        poolManager = _poolManager;\n        validateHookAddress(this);\n    }\n\n    /// @dev Only the pool manager may call this function\n    modifier poolManagerOnly() {\n        if (msg.sender != address(poolManager)) revert NotPoolManager();\n        _;\n    }\n\n    /// @dev Only this address may call this function\n    modifier selfOnly() {\n        if (msg.sender != address(this)) revert NotSelf();\n        _;\n    }\n\n    /// @dev Only pools with hooks set to this contract may call this function\n    modifier onlyValidPools(IHooks hooks) {\n        if (hooks != this) revert InvalidPool();\n        _;\n    }\n\n    function getHooksCalls() public pure virtual returns (Hooks.Calls memory);\n\n    // this function is virtual so that we can override it during testing,\n    // which allows us to deploy an implementation to any address\n    // and then etch the bytecode into the correct address\n    function validateHookAddress(BaseHook _this) internal pure virtual {\n        Hooks.validateHookAddress(_this, getHooksCalls());\n    }\n\n    function lockAcquired(\n        bytes calldata data\n    ) external virtual poolManagerOnly returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).call(data);\n        if (success) return returnData;\n        if (returnData.length == 0) revert LockFailure();\n        // if the call failed, bubble up the reason\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(returnData, 32), mload(returnData))\n        }\n    }\n\n    function beforeInitialize(\n        address,\n        PoolKey calldata,\n        uint160,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterInitialize(\n        address,\n        PoolKey calldata,\n        uint160,\n        int24,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterModifyPosition(\n        address,\n        PoolKey calldata,\n        IPoolManager.ModifyPositionParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterSwap(\n        address,\n        PoolKey calldata,\n        IPoolManager.SwapParams calldata,\n        BalanceDelta,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function beforeDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n\n    function afterDonate(\n        address,\n        PoolKey calldata,\n        uint256,\n        uint256,\n        bytes calldata\n    ) external virtual returns (bytes4) {\n        revert HookNotImplemented();\n    }\n}\n"
    },
    "contracts/IChronicle.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @title IChronicle\n *\n * @notice Interface for Chronicle Protocol's oracle products\n */\ninterface IChronicle {\n    /// @notice Returns the oracle's identifier.\n    /// @return wat The oracle's identifier.\n    function wat() external view returns (bytes32 wat);\n\n    /// @notice Returns the oracle's current value.\n    /// @dev Reverts if no value set.\n    /// @return value The oracle's current value.\n    function read() external view returns (uint value);\n\n    /// @notice Returns the oracle's current value and its age.\n    /// @dev Reverts if no value set.\n    /// @return value The oracle's current value.\n    /// @return age The value's age.\n    function readWithAge() external view returns (uint value, uint age);\n\n    /// @notice Returns the oracle's current value.\n    /// @return isValid True if value exists, false otherwise.\n    /// @return value The oracle's current value if it exists, zero otherwise.\n    function tryRead() external view returns (bool isValid, uint value);\n\n    /// @notice Returns the oracle's current value and its age.\n    /// @return isValid True if value exists, false otherwise.\n    /// @return value The oracle's current value if it exists, zero otherwise.\n    /// @return age The value's age if value exists, zero otherwise.\n    function tryReadWithAge()\n        external\n        view\n        returns (bool isValid, uint value, uint age);\n}"
    },
    "contracts/IDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\ninterface IDataProvider {\n\tfunction getLabel() external view returns (string memory);\n\n\tfunction getMetricData() external view returns (uint256);\n\n\tfunction getTags() external view returns (string[] memory);\n\n\tfunction getDataTimestamp() external view returns (uint256);\n\n\tfunction getDataType() external view returns (DataTypes);\n\n\tfunction getAssetAddress() external view returns (address);\n\n\tfunction getChainId() external view returns (uint32);\n}\n\nenum DataTypes {\n\tPRICE,\n\tLIQUIDITY,\n\tTOTAL_SUPPLY,\n\tCATEGORY,\n\tOTHER\n}\n\nstruct Data {\n\tstring label;\n\taddress assetAddress;\n\tuint256 metricData;\n\tuint256 dataTimestamp;\n\tDataTypes dataType;\n\tuint32 chainId;\n\n}\n"
    },
    "contracts/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n\tfunction name() external view returns (string memory);\n\tfunction symbol() external view returns (string memory);\n\tfunction decimals() external view returns (uint8);\n\tfunction totalSupply() external view returns (uint256);\n\tfunction balanceOf(address account) external view returns (uint256);\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\tfunction allowance(address owner, address spender) external view returns (uint256);\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\tfunction transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}"
    },
    "contracts/ILiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\ninterface ILiquidityProvider {\n    function getTokenLiquidity(address tokenA) external view returns (uint256);\n}"
    },
    "contracts/IndexGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { DataAggregator, TokenInfo, AggregatorParams } from \"./DataAggregator.sol\";\n\ncontract IndexGenerator is DataAggregator {\n\tuint256 public indexSize;\n\n\tconstructor(\n\t\tTokenInfo[] memory _tokenInfo,\n\t\taddress _endpoint,\n\t\taddress[] memory _dataProviders,\n\t\tAggregatorParams memory _aggregatorParams,\n\t\tuint256 indexSize\n\t) DataAggregator(_tokenInfo, _endpoint, _dataProviders, _aggregatorParams) {\n\t\tindexSize = indexSize;\n\t}\n\n\tfunction persistIndex(\n\t\tuint256[] memory indexOrders,\n\t\tstring memory tag\n\t) public returns (bool) {\n\t\trequire(\n\t\t\tindexOrders.length == indexSize,\n\t\t\t\"IndexAggregator: Invalid length of indexOrders\"\n\t\t);\n\n\t\t// indexOrders is an array index order [2,0,1] means 2nd token, 0th token, 1st token for price calculation\n\n\t\t// if (\n\t\t// \tkeccak256(abi.encodePacked(tag)) != keccak256(abi.encodePacked(\"\"))\n\t\t// ) {\n\t\t// \tfor (uint256 i = 0; i < tmpTokens.length; i++) {\n\t\t// \t\tdelete tmpTokens[i];\n\t\t// \t}\n\t\t// \tfor (uint256 i = 0; i < tokenInfo.length; i++) {\n\t\t// \t\tfor (uint256 j = 0; j < tokenInfo[i]._tags.length; j++) {\n\t\t// \t\t\tif (\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tokenInfo[i]._tags[j])) ==\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tag))\n\t\t// \t\t\t) {\n\t\t// \t\t\t\t// need to check if the tag was verified on the tagging system\n\t\t// \t\t\t\t// require(\n\t\t// \t\t\t\t//     taggingVerifier.tokenSymbolToVerifiedTagsMap(tokenInfo[i]._symbol, tag) == true,\n\t\t// \t\t\t\t//     \"IndexAggregator: Tag not verified\"\n\t\t// \t\t\t\t// );\n\t\t// \t\t\t\ttmpTokens.push(tokenInfo[i]);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \trequire(\n\t\t// \t\ttmpTokens.length == indexOrders.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of token with required tags\"\n\t\t// \t);\n\t\t// } else {\n\t\t// \trequire(\n\t\t// \t\tindexOrders.length == tokenInfo.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of indexOrders\"\n\t\t// \t);\n\t\t// }\n\n\t\tuint256 token_a_value;\n\t\tuint256 token_b_value;\n\t\tfor (uint256 i = 0; i < indexOrders.length - 1; i++) {\n\t\t\ttoken_a_value = 0;\n\t\t\ttoken_b_value = 0;\n\n\t\t\tfor (uint256 j = 0; j < movingAverage[indexOrders[i]].length; j++) {\n\t\t\t\ttoken_a_value +=\n\t\t\t\t\tmovingAverage[indexOrders[i]][j] *\n\t\t\t\t\ttotalSupplies[indexOrders[i]];\n\t\t\t\ttoken_b_value +=\n\t\t\t\t\tmovingAverage[indexOrders[i + 1]][j] *\n\t\t\t\t\ttotalSupplies[indexOrders[i + 1]];\n\t\t\t}\n\n\t\t\trequire(token_a_value > 0, \"IndexAggregator: Token value is zero\");\n\t\t\trequire(token_b_value > 0, \"IndexAggregator: Token value is zero\");\n\t\t\trequire(\n\t\t\t\ttoken_a_value > token_b_value,\n\t\t\t\t\"IndexAggregator: order is not correct\"\n\t\t\t);\n\t\t}\n\n\t\tlastIndexOrder = indexOrders;\n\t\tlastIndexTimestamp = block.timestamp;\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}"
    },
    "contracts/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool{\n    function liquidity() external view returns (uint128);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}"
    },
    "contracts/LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IUniswapV3Factory.sol\";\nimport \"./IUniswapV3Pool.sol\";\n\n\ncontract LiquidityManager {\n    IUniswapV3Factory public factory;\n    uint24[] public feeTiers = [500, 3000, 10000]; // Example fee tiers: 0.05%, 0.3%, 1% these are Uniswap V3 standards\n    address[] public comparisonTokens;\n\n    constructor(address _factory, address[] memory _comparisonTokens) {\n        factory = IUniswapV3Factory(_factory);\n        comparisonTokens = _comparisonTokens;\n    }\n\n    function getPoolsForToken(address token) public view returns (address[] memory) {\n        uint256 poolCount = 0;\n        address[] memory tempPools = new address[](comparisonTokens.length * feeTiers.length);\n\n        for (uint256 i = 0; i < comparisonTokens.length; i++) {\n            if (comparisonTokens[i] == token) continue;\n            for (uint256 j = 0; j < feeTiers.length; j++) {\n                address pool = factory.getPool(token, comparisonTokens[i], feeTiers[j]);\n                if (pool != address(0)) {\n                    tempPools[poolCount] = pool;\n                    poolCount++;\n                }\n            }\n        }\n\n        // Create an array of the actual size\n        address[] memory pools = new address[](poolCount);\n        for (uint256 i = 0; i < poolCount; i++) {\n            pools[i] = tempPools[i];\n        }\n\n        return pools;\n    }\n\n    function getTotalLiquidityForToken(address token) public view returns (uint256 totalLiquidity) {\n        address[] memory pools = getPoolsForToken(token);\n        for (uint256 i = 0; i < pools.length; i++) {\n            totalLiquidity += 1;\n            IUniswapV3Pool(pools[i]).liquidity();\n        }\n        return totalLiquidity;\n    }\n}\n"
    },
    "contracts/lz.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { OApp, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\ncontract MyOApp is OApp {\n    constructor(address _endpoint) OApp(_endpoint, msg.sender) {}\n\n    string public data = \"Nothing received yet.\";\n\n    /**\n     * @notice Sends a message from the source chain to a destination chain.\n     * @param _dstEid The endpoint ID of the destination chain.\n     * @param _message The message string to be sent.\n     * @param _options Additional options for message execution.\n     * @dev Encodes the message as bytes and sends it using the `_lzSend` internal function.\n     * @return receipt A `MessagingReceipt` struct containing details of the message sent.\n     */\n    function send(\n        uint32 _dstEid,\n        string memory _message,\n        bytes calldata _options\n    ) external payable returns (MessagingReceipt memory receipt) {\n        bytes memory _payload = abi.encode(_message);\n        receipt = _lzSend(_dstEid, _payload, _options, MessagingFee(msg.value, 0), payable(msg.sender));\n    }\n\n    /**\n     * @notice Quotes the gas needed to pay for the full omnichain transaction in native gas or ZRO token.\n     * @param _dstEid Destination chain's endpoint ID.\n     * @param _message The message.\n     * @param _options Message execution options (e.g., for sending gas to destination).\n     * @param _payInLzToken Whether to return fee in ZRO token.\n     * @return fee A `MessagingFee` struct containing the calculated gas fee in either the native token or ZRO token.\n     */\n    function quote(\n        uint32 _dstEid,\n        string memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) public view returns (MessagingFee memory fee) {\n        bytes memory payload = abi.encode(_message);\n        // return MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), payload, _options, _payInLzToken);\n        fee = _quote(_dstEid, payload, _options, _payInLzToken);\n        // return MessagingFee(0, 10);\n    }\n\n    /**\n     * @dev Internal function override to handle incoming messages from another chain.\n     * @dev _origin A struct containing information about the message sender.\n     * @dev _guid A unique global packet identifier for the message.\n     * @param payload The encoded message payload being received.\n     *\n     * @dev The following params are unused in the current implementation of the OApp.\n     * @dev _executor The address of the Executor responsible for processing the message.\n     * @dev _extraData Arbitrary data appended by the Executor to the message.\n     *\n     * Decodes the received payload and processes it as per the business logic defined in the function.\n     */\n    function _lzReceive(\n        Origin calldata /*_origin*/,\n        bytes32 /*_guid*/,\n        bytes calldata payload,\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) internal override {\n        data = abi.decode(payload, (string));\n    }\n}\n"
    },
    "contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    /// @notice Thrown when trying to interact with an Oracle of a non-initialized pool\n    error OracleCardinalityCannotBeZero();\n\n    /// @notice Thrown when trying to observe a price that is older than the oldest recorded price\n    /// @param oldestTimestamp Timestamp of the oldest remaining observation\n    /// @param targetTimestamp Invalid timestamp targeted to be observed\n    error TargetPredatesOldestObservation(uint32 oldestTimestamp, uint32 targetTimestamp);\n\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(Observation memory last, uint32 blockTimestamp, int24 tick, uint128 liquidity)\n        private\n        pure\n        returns (Observation memory)\n    {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n            return Observation({\n                blockTimestamp: blockTimestamp,\n                tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128\n                    + ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                initialized: true\n            });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        unchecked {\n            Observation memory last = self[index];\n\n            // early return if we've already written an observation this block\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n            // if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(Observation[65535] storage self, uint16 current, uint16 next) internal returns (uint16) {\n        unchecked {\n            if (current == 0) revert OracleCardinalityCannotBeZero();\n            // no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            for (uint16 i = current; i < next; i++) {\n                self[i].blockTimestamp = 1;\n            }\n            return next;\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(uint32 time, uint32 a, uint32 b) private pure returns (bool) {\n        unchecked {\n            // if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2 ** 32;\n            uint256 bAdjusted = b > time ? b : b + 2 ** 32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(Observation[65535] storage self, uint32 time, uint32 target, uint16 index, uint16 cardinality)\n        private\n        view\n        returns (Observation memory beforeOrAt, Observation memory atOrAfter)\n    {\n        unchecked {\n            uint256 l = (index + 1) % cardinality; // oldest observation\n            uint256 r = l + cardinality - 1; // newest observation\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                // check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            // optimistically set before to the newest observation\n            beforeOrAt = self[index];\n\n            // if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    // otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n                }\n            }\n\n            // now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            // ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) {\n                revert TargetPredatesOldestObservation(beforeOrAt.blockTimestamp, target);\n            }\n\n            // if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        unchecked {\n            if (secondsAgo == 0) {\n                Observation memory last = self[index];\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) =\n                getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n            } else {\n                // we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return (\n                    beforeOrAt.tickCumulative\n                        + ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta)))\n                            * int56(uint56(targetDelta)),\n                    beforeOrAt.secondsPerLiquidityCumulativeX128\n                        + uint160(\n                            (\n                                uint256(\n                                    atOrAfter.secondsPerLiquidityCumulativeX128\n                                        - beforeOrAt.secondsPerLiquidityCumulativeX128\n                                ) * targetDelta\n                            ) / observationTimeDelta\n                        )\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        unchecked {\n            if (cardinality == 0) revert OracleCardinalityCannotBeZero();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) =\n                    observeSingle(self, time, secondsAgos[i], tick, index, liquidity, cardinality);\n            }\n        }\n    }\n}"
    },
    "contracts/PythReader.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\n\ncontract PythDataProvider is IDataProvider {\n\tIPyth pyth;\n\tbytes32 tokenToUsdPriceId;\n\taddress token;\n\tuint32 chainId;\n\n\tconstructor(\n\t\taddress _pyth,\n\t\tbytes32 _priceId,\n\t\taddress _token,\n\t\tuint32 _chainId\n\t) {\n\t\tpyth = IPyth(_pyth);\n\t\ttokenToUsdPriceId = _priceId;\n\t\ttoken = _token;\n\t\tchainId = _chainId;\n\t}\n\n\tfunction eighteenDecimalsPrice() public view returns (uint256) {\n\t\tPythStructs.Price memory price = pyth.getPrice(tokenToUsdPriceId);\n\n\t\tuint pricedecimals = (uint(uint64(price.price)) * (10 ** 18)) /\n\t\t\t(10 ** uint8(uint32(-1 * price.expo)));\n\t\treturn pricedecimals;\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn string(abi.encodePacked(\"pricePyth\", IERC20(token).name()));\n\t}\n\n\tfunction getMetricData() external view override returns (uint256) {\n\t\treturn eighteenDecimalsPrice();\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"partner\";\n\t\ttags[1] = \"pyth\";\n\t\ttags[2] = \"price\";\n\t\ttags[3] = IERC20(token).name();\n\t\treturn tags;\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.PRICE;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\n\tfunction getChainId() external view override returns (uint32) {\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/TotalSupplyProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\n\ncontract TotalSupplyProvider is IDataProvider {\n\taddress public token;\n\tuint32 public chainId;\n\n\tconstructor(address _token, uint32 _chainId) {\n\t\ttoken = _token;\n\t\tchainId = _chainId;\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn\n\t\t\tstring(\n\t\t\t\tabi.encodePacked(\"totalSupply\", IERC20(address(token)).name())\n\t\t\t);\n\t}\n\n\tfunction getMetricData() external view override returns (uint256) {\n\t\treturn IERC20(token).totalSupply();\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"onchain\";\n\t\ttags[1] = \"supply\";\n\t\ttags[2] = IERC20(address(token)).name();\n\t\treturn tags;\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.TOTAL_SUPPLY;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\n\tfunction getChainId() external view override returns (uint32) {\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/Uniswap/V3-Helpers/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V4-Core/Claims.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {IClaims} from \"./interfaces/IClaims.sol\";\n\n/// An intentionally barebones balance mapping only supporting mint/burn/transfer\ncontract Claims is IClaims {\n    using CurrencyLibrary for Currency;\n\n    // Mapping from Currency to account balances\n    mapping(Currency currency => mapping(address account => uint256)) private balances;\n\n    /// @inheritdoc IClaims\n    function balanceOf(address account, Currency currency) public view returns (uint256) {\n        return balances[currency][account];\n    }\n\n    /// @inheritdoc IClaims\n    function transfer(address to, Currency currency, uint256 amount) public {\n        if (to == address(this)) revert InvalidAddress();\n\n        if (amount > balances[currency][msg.sender]) revert InsufficientBalance();\n        unchecked {\n            balances[currency][msg.sender] -= amount;\n        }\n        balances[currency][to] += amount;\n        emit Transfer(msg.sender, to, currency, amount);\n    }\n\n    /// @notice Mint `amount` of currency to address\n    /// @param to The address to mint to\n    /// @param currency The currency to mint\n    /// @param amount The amount to mint\n    function _mint(address to, Currency currency, uint256 amount) internal {\n        balances[currency][to] += amount;\n        emit Mint(to, currency, amount);\n    }\n\n    /// @notice Burn `amount` of currency from msg.sender\n    /// @param currency The currency to mint\n    /// @param amount The amount to burn\n    /// @dev Will revert if the sender does not have enough balance\n    function _burn(Currency currency, uint256 amount) internal {\n        if (amount > balances[currency][msg.sender]) revert InsufficientBalance();\n        unchecked {\n            balances[currency][msg.sender] -= amount;\n        }\n        emit Burn(msg.sender, currency, amount);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/Fees.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.19;\n\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {IProtocolFeeController} from \"./interfaces/IProtocolFeeController.sol\";\nimport {IHookFeeManager} from \"./interfaces/IHookFeeManager.sol\";\nimport {IFees} from \"./interfaces/IFees.sol\";\nimport {FeeLibrary} from \"./libraries/FeeLibrary.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {Owned} from \"./Owned.sol\";\nimport {IDynamicFeeManager} from \"./interfaces/IDynamicFeeManager.sol\";\nimport \"hardhat/console.sol\";\n\nabstract contract Fees is IFees, Owned {\n    using FeeLibrary for uint24;\n    using CurrencyLibrary for Currency;\n\n    uint8 public constant MIN_PROTOCOL_FEE_DENOMINATOR = 4;\n\n    // the swap fee is represented in hundredths of a bip, so the max is 100%\n    uint24 public constant MAX_SWAP_FEE = 1000000;\n\n    mapping(Currency currency => uint256) public protocolFeesAccrued;\n\n    mapping(address hookAddress => mapping(Currency currency => uint256))\n        public hookFeesAccrued;\n\n    IProtocolFeeController public protocolFeeController;\n\n    uint256 private immutable controllerGasLimit;\n\n    constructor(uint256 _controllerGasLimit) {\n        controllerGasLimit = _controllerGasLimit;\n    }\n\n    function _fetchProtocolFees(\n        PoolKey memory key\n    ) internal view returns (uint24 protocolFees) {\n        uint16 protocolSwapFee;\n        uint16 protocolWithdrawFee;\n        if (address(protocolFeeController) != address(0)) {\n            // note that EIP-150 mandates that calls requesting more than 63/64ths of remaining gas\n            // will be allotted no more than this amount, so controllerGasLimit must be set with this\n            // in mind.\n            if (gasleft() < controllerGasLimit)\n                revert ProtocolFeeCannotBeFetched();\n            try\n                protocolFeeController.protocolFeesForPool{\n                    gas: controllerGasLimit\n                }(key)\n            returns (uint24 updatedProtocolFees) {\n                protocolSwapFee = uint16(updatedProtocolFees >> 12);\n                protocolWithdrawFee = uint16(updatedProtocolFees & 0xFFF);\n\n                protocolFees = updatedProtocolFees;\n            } catch {}\n            _checkProtocolFee(protocolSwapFee);\n            _checkProtocolFee(protocolWithdrawFee);\n        }\n    }\n\n    /// @notice There is no cap on the hook fee, but it is specified as a percentage taken on the amount after the protocol fee is applied, if there is a protocol fee.\n    function _fetchHookFees(\n        PoolKey memory key\n    ) internal view returns (uint24 hookFees) {\n        if (address(key.hooks) != address(0)) {\n            try IHookFeeManager(address(key.hooks)).getHookFees(key) returns (\n                uint24 hookFeesRaw\n            ) {\n                uint24 swapFeeMask = key.fee.hasHookSwapFee() ? 0xFFF000 : 0;\n                uint24 withdrawFeeMask = key.fee.hasHookWithdrawFee()\n                    ? 0xFFF\n                    : 0;\n                uint24 fullFeeMask = swapFeeMask | withdrawFeeMask;\n                hookFees = hookFeesRaw & fullFeeMask;\n            } catch {}\n        }\n    }\n\n    function _fetchDynamicSwapFee(\n        PoolKey memory key\n    ) internal view returns (uint24 dynamicSwapFee) {\n        dynamicSwapFee = IDynamicFeeManager(address(key.hooks)).getFee(\n            msg.sender,\n            key\n        );\n        if (dynamicSwapFee >= MAX_SWAP_FEE) revert FeeTooLarge();\n    }\n\n    /// @dev Only the lower 12 bits are used here to encode the fee denominator.\n    function _checkProtocolFee(uint16 fee) internal pure {\n        if (fee != 0) {\n            uint16 fee0 = fee % 64;\n            uint16 fee1 = fee >> 6;\n            // The fee is specified as a denominator so it cannot be LESS than the MIN_PROTOCOL_FEE_DENOMINATOR (unless it is 0).\n            if (\n                (fee0 != 0 && fee0 < MIN_PROTOCOL_FEE_DENOMINATOR) ||\n                (fee1 != 0 && fee1 < MIN_PROTOCOL_FEE_DENOMINATOR)\n            ) {\n                revert FeeTooLarge();\n            }\n        }\n    }\n\n    function setProtocolFeeController(\n        IProtocolFeeController controller\n    ) external onlyOwner {\n        protocolFeeController = controller;\n        emit ProtocolFeeControllerUpdated(address(controller));\n    }\n\n    function collectProtocolFees(\n        address recipient,\n        Currency currency,\n        uint256 amount\n    ) external returns (uint256 amountCollected) {\n        if (msg.sender != owner && msg.sender != address(protocolFeeController))\n            revert InvalidCaller();\n\n        amountCollected = (amount == 0)\n            ? protocolFeesAccrued[currency]\n            : amount;\n        protocolFeesAccrued[currency] -= amountCollected;\n        currency.transfer(recipient, amountCollected);\n    }\n\n    function collectHookFees(\n        address recipient,\n        Currency currency,\n        uint256 amount\n    ) external returns (uint256 amountCollected) {\n        address hookAddress = msg.sender;\n\n        amountCollected = (amount == 0)\n            ? hookFeesAccrued[hookAddress][currency]\n            : amount;\n        recipient = (recipient == address(0)) ? hookAddress : recipient;\n\n        hookFeesAccrued[hookAddress][currency] -= amountCollected;\n        currency.transfer(recipient, amountCollected);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/callback/ILockCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface ILockCallback {\n    /// @notice Called by the pool manager on `msg.sender` when a lock is acquired\n    /// @param data The data that was passed to the call to lock\n    /// @return Any data that you want to be returned from the lock call\n    function lockAcquired(bytes calldata data) external returns (bytes memory);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/external/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IClaims.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Currency} from \"../types/Currency.sol\";\n\ninterface IClaims {\n    /// @notice Thrown when user has insufficient Claims balance\n    error InsufficientBalance();\n\n    /// @notice Thrown when transferring Claims to this address\n    error InvalidAddress();\n\n    /// @notice Get the balance of `account` for `currency`\n    /// @param account The account to get the balance of\n    /// @param currency The currency to get the balance of\n    function balanceOf(address account, Currency currency) external returns (uint256);\n\n    /// @notice Transfer `amount` of `currency` from sender to `to`\n    /// @param to The address to transfer to\n    /// @param currency The currency to transfer\n    /// @param amount The amount to transfer\n    /// @dev Will revert if the sender does not have enough balance\n    function transfer(address to, Currency currency, uint256 amount) external;\n\n    /// @notice Emitted when minting `amount` of currency Claims to address\n    event Mint(address indexed to, Currency indexed currency, uint256 amount);\n    /// @notice Emitted when burning `amount` of currency Claims from address\n    event Burn(address indexed from, Currency indexed currency, uint256 amount);\n    /// @notice Emitted when transferring `amount` of currency Claims\n    event Transfer(address indexed from, address indexed to, Currency indexed currency, uint256 amount);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IDynamicFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The dynamic fee manager determines fees for pools\n/// @dev note that this pool is only called if the PoolKey fee value is equal to the DYNAMIC_FEE magic value\ninterface IDynamicFeeManager {\n    function getFee(address sender, PoolKey calldata key) external view returns (uint24);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IFees.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Currency} from \"../types/Currency.sol\";\n\ninterface IFees {\n    /// @notice Thrown when the protocol fee denominator is less than 4. Also thrown when the static or dynamic fee on a pool is exceeds 100%.\n    error FeeTooLarge();\n    /// @notice Thrown when not enough gas is provided to look up the protocol fee\n    error ProtocolFeeCannotBeFetched();\n    /// @notice Thrown when a pool does not have a dynamic fee.\n    error FeeNotDynamic();\n\n    event ProtocolFeeControllerUpdated(address protocolFeeController);\n\n    /// @notice Returns the minimum denominator for the protocol fee, which restricts it to a maximum of 25%\n    function MIN_PROTOCOL_FEE_DENOMINATOR() external view returns (uint8);\n\n    /// @notice Given a currency address, returns the protocol fees accrued in that currency\n    function protocolFeesAccrued(Currency) external view returns (uint256);\n\n    /// @notice Given a hook and a currency address, returns the fees accrued\n    function hookFeesAccrued(address, Currency) external view returns (uint256);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IHookFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\n/// @notice The interface for setting a fee on swap or fee on withdraw to the hook\n/// @dev This callback is only made if the Fee.HOOK_SWAP_FEE_FLAG or Fee.HOOK_WITHDRAW_FEE_FLAG in set in the pool's key.fee.\ninterface IHookFeeManager {\n    /// @notice Gets the fee a hook can take at swap/withdraw. Upper bits used for swap and lower bits for withdraw.\n    /// @param key The pool key\n    /// @return The hook fees for swapping (upper bits set) and withdrawing (lower bits set).\n    function getHookFees(PoolKey calldata key) external view returns (uint24);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IHooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\nimport {BalanceDelta} from \"../types/BalanceDelta.sol\";\nimport {IPoolManager} from \"./IPoolManager.sol\";\n\n/// @notice The PoolManager contract decides whether to invoke specific hooks by inspecting the leading bits\n/// of the hooks contract address. For example, a 1 bit in the first bit of the address will\n/// cause the 'before swap' hook to be invoked. See the Hooks library for the full spec.\n/// @dev Should only be callable by the v4 PoolManager.\ninterface IHooks {\n    /// @notice The hook called before the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, bytes calldata hookData)\n        external\n        returns (bytes4);\n\n    /// @notice The hook called after the state of a pool is initialized\n    /// @param sender The initial msg.sender for the initialize call\n    /// @param key The key for the pool being initialized\n    /// @param sqrtPriceX96 The sqrt(price) of the pool as a Q64.96\n    /// @param tick The current tick after the state of a pool is initialized\n    /// @param hookData Arbitrary data handed into the PoolManager by the initializer to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterInitialize(\n        address sender,\n        PoolKey calldata key,\n        uint160 sqrtPriceX96,\n        int24 tick,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a position is modified\n    /// @param sender The initial msg.sender for the modify position call\n    /// @param key The key for the pool\n    /// @param params The parameters for modifying the position\n    /// @param hookData Arbitrary data handed into the PoolManager by the liquidty provider to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterModifyPosition(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.ModifyPositionParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after a swap\n    /// @param sender The initial msg.sender for the swap call\n    /// @param key The key for the pool\n    /// @param params The parameters for the swap\n    /// @param delta The amount owed to the locker (positive) or owed to the pool (negative)\n    /// @param hookData Arbitrary data handed into the PoolManager by the swapper to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterSwap(\n        address sender,\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called before donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function beforeDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n\n    /// @notice The hook called after donate\n    /// @param sender The initial msg.sender for the donate call\n    /// @param key The key for the pool\n    /// @param amount0 The amount of token0 being donated\n    /// @param amount1 The amount of token1 being donated\n    /// @param hookData Arbitrary data handed into the PoolManager by the donor to be be passed on to the hook\n    /// @return bytes4 The function selector for the hook\n    function afterDonate(\n        address sender,\n        PoolKey calldata key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IPoolManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { Currency } from \"../types/Currency.sol\";\nimport { PoolKey } from \"../types/PoolKey.sol\";\nimport { Pool } from \"../libraries/Pool.sol\";\nimport { IHooks } from \"./IHooks.sol\";\nimport { IFees } from \"./IFees.sol\";\nimport { IClaims } from \"./IClaims.sol\";\nimport { BalanceDelta } from \"../types/BalanceDelta.sol\";\nimport { PoolId } from \"../types/PoolId.sol\";\nimport { Position } from \"../libraries/Position.sol\";\n\ninterface IPoolManager is IFees, IClaims {\n\t/// @notice Thrown when currencies touched has exceeded max of 256\n\terror MaxCurrenciesTouched();\n\n\t/// @notice Thrown when a currency is not netted out after a lock\n\terror CurrencyNotSettled();\n\n\t/// @notice Thrown when a function is called by an address that is not the current locker\n\t/// @param locker The current locker\n\terror LockedBy(address locker);\n\n\t/// @notice The ERC1155 being deposited is not the Uniswap ERC1155\n\terror NotPoolManagerToken();\n\n\t/// @notice Pools are limited to type(int16).max tickSpacing in #initialize, to prevent overflow\n\terror TickSpacingTooLarge();\n\t/// @notice Pools must have a positive non-zero tickSpacing passed to #initialize\n\terror TickSpacingTooSmall();\n\n\t/// @notice PoolKey must have currencies where address(currency0) < address(currency1)\n\terror CurrenciesInitializedOutOfOrder();\n\n\t/// @notice Emitted when a new pool is initialized\n\t/// @param id The abi encoded hash of the pool key struct for the new pool\n\t/// @param currency0 The first currency of the pool by address sort order\n\t/// @param currency1 The second currency of the pool by address sort order\n\t/// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n\t/// @param tickSpacing The minimum number of ticks between initialized ticks\n\t/// @param hooks The hooks contract address for the pool, or address(0) if none\n\tevent Initialize(\n\t\tPoolId indexed id,\n\t\tCurrency indexed currency0,\n\t\tCurrency indexed currency1,\n\t\tuint24 fee,\n\t\tint24 tickSpacing,\n\t\tIHooks hooks\n\t);\n\n\t/// @notice Emitted when a liquidity position is modified\n\t/// @param id The abi encoded hash of the pool key struct for the pool that was modified\n\t/// @param sender The address that modified the pool\n\t/// @param tickLower The lower tick of the position\n\t/// @param tickUpper The upper tick of the position\n\t/// @param liquidityDelta The amount of liquidity that was added or removed\n\tevent ModifyPosition(\n\t\tPoolId indexed id,\n\t\taddress indexed sender,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tint256 liquidityDelta\n\t);\n\n\t/// @notice Emitted for swaps between currency0 and currency1\n\t/// @param id The abi encoded hash of the pool key struct for the pool that was modified\n\t/// @param sender The address that initiated the swap call, and that received the callback\n\t/// @param amount0 The delta of the currency0 balance of the pool\n\t/// @param amount1 The delta of the currency1 balance of the pool\n\t/// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n\t/// @param liquidity The liquidity of the pool after the swap\n\t/// @param tick The log base 1.0001 of the price of the pool after the swap\n\tevent Swap(\n\t\tPoolId indexed id,\n\t\taddress indexed sender,\n\t\tint128 amount0,\n\t\tint128 amount1,\n\t\tuint160 sqrtPriceX96,\n\t\tuint128 liquidity,\n\t\tint24 tick,\n\t\tuint24 fee\n\t);\n\n\tevent ProtocolFeeUpdated(PoolId indexed id, uint24 protocolFees);\n\n\tevent HookFeeUpdated(PoolId indexed id, uint24 hookFees);\n\n\tevent DynamicSwapFeeUpdated(PoolId indexed id, uint24 dynamicSwapFee);\n\n\t/// @notice Returns the constant representing the maximum tickSpacing for an initialized pool key\n\tfunction MAX_TICK_SPACING() external view returns (int24);\n\n\t/// @notice Returns the constant representing the minimum tickSpacing for an initialized pool key\n\tfunction MIN_TICK_SPACING() external view returns (int24);\n\n\t/// @notice Get the current value in slot0 of the given pool\n\tfunction getSlot0(\n\t\tPoolId id\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint160 sqrtPriceX96,\n\t\t\tint24 tick,\n\t\t\tuint24 protocolFees,\n\t\t\tuint24 hookFees\n\t\t);\n\n\t/// @notice Get the current value of liquidity of the given pool\n\tfunction getLiquidity(PoolId id) external view returns (uint128 liquidity);\n\n\t/// @notice Get the current value of liquidity for the specified pool and position\n\tfunction getLiquidity(\n\t\tPoolId id,\n\t\taddress owner,\n\t\tint24 tickLower,\n\t\tint24 tickUpper\n\t) external view returns (uint128 liquidity);\n\n\t/// @notice Get the position struct for a specified pool and position\n\tfunction getPosition(\n\t\tPoolId id,\n\t\taddress owner,\n\t\tint24 tickLower,\n\t\tint24 tickUpper\n\t) external view returns (Position.Info memory position);\n\n\t/// @notice Returns the reserves for a given ERC20 currency\n\tfunction reservesOf(Currency currency) external view returns (uint256);\n\n\t/// @notice Contains data about pool lockers.\n\tstruct LockData {\n\t\t/// @notice The current number of active lockers\n\t\tuint128 length;\n\t\t/// @notice The total number of nonzero deltas over all active + completed lockers\n\t\tuint128 nonzeroDeltaCount;\n\t}\n\n\t/// @notice Returns the locker in the ith position of the locker queue.\n\tfunction getLock(uint256 i) external view returns (address locker);\n\n\t/// @notice Returns lock data\n\tfunction lockData()\n\t\texternal\n\t\tview\n\t\treturns (uint128 length, uint128 nonzeroDeltaCount);\n\n\t/// @notice Initialize the state for a given pool ID\n\tfunction initialize(\n\t\tPoolKey memory key,\n\t\tuint160 sqrtPriceX96,\n\t\tbytes calldata hookData\n\t) external returns (int24 tick);\n\n\t/// @notice Get the current delta for a locker in the given currency\n\t/// @param locker The address of the locker\n\t/// @param currency The currency for which to lookup the delta\n\tfunction currencyDelta(\n\t\taddress locker,\n\t\tCurrency currency\n\t) external view returns (int256);\n\n\t/// @notice All operations go through this function\n\t/// @param data Any data to pass to the callback, via `ILockCallback(msg.sender).lockAcquired(data)`\n\t/// @return The data returned by the call to `ILockCallback(msg.sender).lockAcquired(data)`\n\tfunction lock(bytes calldata data) external returns (bytes memory);\n\n\tstruct ModifyPositionParams {\n\t\t// the lower and upper tick of the position\n\t\tint24 tickLower;\n\t\tint24 tickUpper;\n\t\t// how to modify the liquidity\n\t\tint256 liquidityDelta;\n\t}\n\n\t/// @notice Modify the position for the given pool\n\tfunction modifyPosition(\n\t\tPoolKey memory key,\n\t\tModifyPositionParams memory params,\n\t\tbytes calldata hookData\n\t) external returns (BalanceDelta);\n\n\tstruct SwapParams {\n\t\tbool zeroForOne;\n\t\tint256 amountSpecified;\n\t\tuint160 sqrtPriceLimitX96;\n\t}\n\n\t/// @notice Swap against the given pool\n\tfunction swap(\n\t\tPoolKey memory key,\n\t\tSwapParams memory params,\n\t\tbytes calldata hookData\n\t) external returns (BalanceDelta);\n\n\t/// @notice Donate the given currency amounts to the pool with the given pool key\n\tfunction donate(\n\t\tPoolKey memory key,\n\t\tuint256 amount0,\n\t\tuint256 amount1,\n\t\tbytes calldata hookData\n\t) external returns (BalanceDelta);\n\n\t/// @notice Called by the user to net out some value owed to the user\n\t/// @dev Can also be used as a mechanism for _free_ flash loans\n\tfunction take(Currency currency, address to, uint256 amount) external;\n\n\t/// @notice Called by the user to move value into Claims balance\n\tfunction mint(Currency token, address to, uint256 amount) external;\n\n\t/// @notice Called by the user to redeem their Claims balance\n\tfunction burn(Currency token, uint256 amount) external;\n\n\t/// @notice Called by the user to pay what is owed\n\tfunction settle(Currency token) external payable returns (uint256 paid);\n\n\t/// @notice Sets the protocol's swap and withdrawal fees for the given pool\n\t/// Protocol fees are always a portion of a fee that is owed. If that underlying fee is 0, no protocol fees will accrue even if it is set to > 0.\n\tfunction setProtocolFees(PoolKey memory key) external;\n\n\t/// @notice Sets the hook's swap and withdrawal fees for the given pool\n\tfunction setHookFees(PoolKey memory key) external;\n\n\t/// @notice Updates the pools swap fees for the a pool that has enabled dynamic swap fees.\n\tfunction updateDynamicSwapFee(PoolKey memory key) external;\n\n\t/// @notice Called by external contracts to access granular pool state\n\t/// @param slot Key of slot to sload\n\t/// @return value The value of the slot as bytes32\n\tfunction extsload(bytes32 slot) external view returns (bytes32 value);\n\n\t/// @notice Called by external contracts to access granular pool state\n\t/// @param slot Key of slot to start sloading from\n\t/// @param nSlots Number of slots to load into return value\n\t/// @return value The value of the sload-ed slots concatenated as dynamic bytes\n\tfunction extsload(\n\t\tbytes32 slot,\n\t\tuint256 nSlots\n\t) external view returns (bytes memory value);\n}\n"
    },
    "contracts/Uniswap/V4-Core/interfaces/IProtocolFeeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"../types/PoolKey.sol\";\n\ninterface IProtocolFeeController {\n    /// @notice Returns the protocol fees for a pool given the conditions of this contract\n    /// @param poolKey The pool key to identify the pool. The controller may want to use attributes on the pool\n    ///   to determine the protocol fee, hence the entire key is needed.\n    function protocolFeesForPool(PoolKey memory poolKey) external view returns (uint24);\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            if (x >= 0x100000000000000000000000000000000) {\n                x >>= 128;\n                r += 128;\n            }\n            if (x >= 0x10000000000000000) {\n                x >>= 64;\n                r += 64;\n            }\n            if (x >= 0x100000000) {\n                x >>= 32;\n                r += 32;\n            }\n            if (x >= 0x10000) {\n                x >>= 16;\n                r += 16;\n            }\n            if (x >= 0x100) {\n                x >>= 8;\n                r += 8;\n            }\n            if (x >= 0x10) {\n                x >>= 4;\n                r += 4;\n            }\n            if (x >= 0x4) {\n                x >>= 2;\n                r += 2;\n            }\n            if (x >= 0x2) r += 1;\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        unchecked {\n            r = 255;\n            if (x & type(uint128).max > 0) {\n                r -= 128;\n            } else {\n                x >>= 128;\n            }\n            if (x & type(uint64).max > 0) {\n                r -= 64;\n            } else {\n                x >>= 64;\n            }\n            if (x & type(uint32).max > 0) {\n                r -= 32;\n            } else {\n                x >>= 32;\n            }\n            if (x & type(uint16).max > 0) {\n                r -= 16;\n            } else {\n                x >>= 16;\n            }\n            if (x & type(uint8).max > 0) {\n                r -= 8;\n            } else {\n                x >>= 8;\n            }\n            if (x & 0xf > 0) {\n                r -= 4;\n            } else {\n                x >>= 4;\n            }\n            if (x & 0x3 > 0) {\n                r -= 2;\n            } else {\n                x >>= 2;\n            }\n            if (x & 0x1 > 0) r -= 1;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FeeLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nlibrary FeeLibrary {\n    uint24 public constant STATIC_FEE_MASK = 0x0FFFFF;\n    uint24 public constant DYNAMIC_FEE_FLAG = 0x800000; // 1000\n    uint24 public constant HOOK_SWAP_FEE_FLAG = 0x400000; // 0100\n    uint24 public constant HOOK_WITHDRAW_FEE_FLAG = 0x200000; // 0010\n\n    function isDynamicFee(uint24 self) internal pure returns (bool) {\n        return self & DYNAMIC_FEE_FLAG != 0;\n    }\n\n    function hasHookSwapFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_SWAP_FEE_FLAG != 0;\n    }\n\n    function hasHookWithdrawFee(uint24 self) internal pure returns (bool) {\n        return self & HOOK_WITHDRAW_FEE_FLAG != 0;\n    }\n\n    function isStaticFeeTooLarge(uint24 self) internal pure returns (bool) {\n        return self & STATIC_FEE_MASK >= 1000000;\n    }\n\n    function getStaticFee(uint24 self) internal pure returns (uint24) {\n        return self & STATIC_FEE_MASK;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(uint256 a, uint256 b, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) > 0) {\n                require(result < type(uint256).max);\n                result++;\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Hooks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IHooks} from \"../interfaces/IHooks.sol\";\nimport {FeeLibrary} from \"../libraries/FeeLibrary.sol\";\n\n/// @notice V4 decides whether to invoke specific hooks by inspecting the leading bits of the address that\n/// the hooks contract is deployed to.\n/// For example, a hooks contract deployed to address: 0x9000000000000000000000000000000000000000\n/// has leading bits '1001' which would cause the 'before initialize' and 'after modify position' hooks to be used.\nlibrary Hooks {\n    using FeeLibrary for uint24;\n\n    uint256 internal constant BEFORE_INITIALIZE_FLAG = 1 << 159;\n    uint256 internal constant AFTER_INITIALIZE_FLAG = 1 << 158;\n    uint256 internal constant BEFORE_MODIFY_POSITION_FLAG = 1 << 157;\n    uint256 internal constant AFTER_MODIFY_POSITION_FLAG = 1 << 156;\n    uint256 internal constant BEFORE_SWAP_FLAG = 1 << 155;\n    uint256 internal constant AFTER_SWAP_FLAG = 1 << 154;\n    uint256 internal constant BEFORE_DONATE_FLAG = 1 << 153;\n    uint256 internal constant AFTER_DONATE_FLAG = 1 << 152;\n\n    struct Calls {\n        bool beforeInitialize;\n        bool afterInitialize;\n        bool beforeModifyPosition;\n        bool afterModifyPosition;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeDonate;\n        bool afterDonate;\n    }\n\n    /// @notice Thrown if the address will not lead to the specified hook calls being called\n    /// @param hooks The address of the hooks contract\n    error HookAddressNotValid(address hooks);\n\n    /// @notice Hook did not return its selector\n    error InvalidHookResponse();\n\n    /// @notice Utility function intended to be used in hook constructors to ensure\n    /// the deployed hooks address causes the intended hooks to be called\n    /// @param calls The hooks that are intended to be called\n    /// @dev calls param is memory as the function will be called from constructors\n    function validateHookAddress(\n        IHooks self,\n        Calls memory calls\n    ) internal pure {\n        if (\n            calls.beforeInitialize != shouldCallBeforeInitialize(self) ||\n            calls.afterInitialize != shouldCallAfterInitialize(self) ||\n            calls.beforeModifyPosition !=\n            shouldCallBeforeModifyPosition(self) ||\n            calls.afterModifyPosition != shouldCallAfterModifyPosition(self) ||\n            calls.beforeSwap != shouldCallBeforeSwap(self) ||\n            calls.afterSwap != shouldCallAfterSwap(self) ||\n            calls.beforeDonate != shouldCallBeforeDonate(self) ||\n            calls.afterDonate != shouldCallAfterDonate(self)\n        ) {\n            revert HookAddressNotValid(address(self));\n        }\n    }\n\n    /// @notice Ensures that the hook address includes at least one hook flag or dynamic fees, or is the 0 address\n    /// @param hook The hook to verify\n    function isValidHookAddress(\n        IHooks hook,\n        uint24 fee\n    ) internal pure returns (bool) {\n        // If there is no hook contract set, then fee cannot be dynamic and there cannot be a hook fee on swap or withdrawal.\n        return\n            address(hook) == address(0)\n                ? !fee.isDynamicFee() &&\n                    !fee.hasHookSwapFee() &&\n                    !fee.hasHookWithdrawFee()\n                : (uint160(address(hook)) >= AFTER_DONATE_FLAG ||\n                    fee.isDynamicFee() ||\n                    fee.hasHookSwapFee() ||\n                    fee.hasHookWithdrawFee());\n    }\n\n    function shouldCallBeforeInitialize(\n        IHooks self\n    ) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallAfterInitialize(\n        IHooks self\n    ) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_INITIALIZE_FLAG != 0;\n    }\n\n    function shouldCallBeforeModifyPosition(\n        IHooks self\n    ) internal pure returns (bool) {\n        return\n            uint256(uint160(address(self))) & BEFORE_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallAfterModifyPosition(\n        IHooks self\n    ) internal pure returns (bool) {\n        return\n            uint256(uint160(address(self))) & AFTER_MODIFY_POSITION_FLAG != 0;\n    }\n\n    function shouldCallBeforeSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_SWAP_FLAG != 0;\n    }\n\n    function shouldCallAfterSwap(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_SWAP_FLAG != 0;\n    }\n\n    function shouldCallBeforeDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & BEFORE_DONATE_FLAG != 0;\n    }\n\n    function shouldCallAfterDonate(IHooks self) internal pure returns (bool) {\n        return uint256(uint160(address(self))) & AFTER_DONATE_FLAG != 0;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/LockDataLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\n\n/// @dev This library manages a custom storage implementation for a queue\n///      that tracks current lockers. The \"sentinel\" storage slot for this data structure,\n///      always passed in as IPoolManager.LockData storage self, stores not just the current\n///      length of the queue but also the global count of non-zero deltas across all lockers.\n///      The values of the data structure start at OFFSET, and each value is a locker address.\nlibrary LockDataLibrary {\n    uint256 private constant OFFSET = uint256(keccak256(\"LockData\"));\n\n    /// @dev Pushes a locker onto the end of the queue, and updates the sentinel storage slot.\n    function push(IPoolManager.LockData storage self, address locker) internal {\n        // read current value from the sentinel storage slot\n        uint128 length = self.length;\n        unchecked {\n            uint256 indexToWrite = OFFSET + length; // not in assembly because OFFSET is in the library scope\n            /// @solidity memory-safe-assembly\n            assembly {\n                // in the next storage slot, write the locker\n                sstore(indexToWrite, locker)\n            }\n            // update the sentinel storage slot\n            self.length = length + 1;\n        }\n    }\n\n    /// @dev Pops a locker off the end of the queue. Note that no storage gets cleared.\n    function pop(IPoolManager.LockData storage self) internal {\n        unchecked {\n            self.length--;\n        }\n    }\n\n    function getLock(uint256 i) internal view returns (address locker) {\n        unchecked {\n            uint256 position = OFFSET + i; // not in assembly because OFFSET is in the library scope\n            /// @solidity memory-safe-assembly\n            assembly {\n                locker := sload(position)\n            }\n        }\n    }\n\n    function getActiveLock(IPoolManager.LockData storage self) internal view returns (address locker) {\n        return getLock(self.length - 1);\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\nimport {TickBitmap} from \"./TickBitmap.sol\";\nimport {Position} from \"./Position.sol\";\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\nimport {TickMath} from \"./TickMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\nimport {SwapMath} from \"./SwapMath.sol\";\nimport {BalanceDelta, toBalanceDelta} from \"../types/BalanceDelta.sol\";\n\nlibrary Pool {\n    using SafeCast for *;\n    using TickBitmap for mapping(int16 => uint256);\n    using Position for mapping(bytes32 => Position.Info);\n    using Position for Position.Info;\n\n    /// @notice Thrown when tickLower is not below tickUpper\n    /// @param tickLower The invalid tickLower\n    /// @param tickUpper The invalid tickUpper\n    error TicksMisordered(int24 tickLower, int24 tickUpper);\n\n    /// @notice Thrown when tickLower is less than min tick\n    /// @param tickLower The invalid tickLower\n    error TickLowerOutOfBounds(int24 tickLower);\n\n    /// @notice Thrown when tickUpper exceeds max tick\n    /// @param tickUpper The invalid tickUpper\n    error TickUpperOutOfBounds(int24 tickUpper);\n\n    /// @notice For the tick spacing, the tick has too much liquidity\n    error TickLiquidityOverflow(int24 tick);\n\n    /// @notice Thrown when interacting with an uninitialized tick that must be initialized\n    /// @param tick The uninitialized tick\n    error TickNotInitialized(int24 tick);\n\n    /// @notice Thrown when trying to initalize an already initialized pool\n    error PoolAlreadyInitialized();\n\n    /// @notice Thrown when trying to interact with a non-initialized pool\n    error PoolNotInitialized();\n\n    /// @notice Thrown when trying to swap amount of 0\n    error SwapAmountCannotBeZero();\n\n    /// @notice Thrown when sqrtPriceLimitX96 on a swap has already exceeded its limit\n    /// @param sqrtPriceCurrentX96 The invalid, already surpassed sqrtPriceLimitX96\n    /// @param sqrtPriceLimitX96 The surpassed price limit\n    error PriceLimitAlreadyExceeded(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceLimitX96\n    );\n\n    /// @notice Thrown when sqrtPriceLimitX96 lies outside of valid tick/price range\n    /// @param sqrtPriceLimitX96 The invalid, out-of-bounds sqrtPriceLimitX96\n    error PriceLimitOutOfBounds(uint160 sqrtPriceLimitX96);\n\n    /// @notice Thrown by donate if there is currently 0 liquidity, since the fees will not go to any liquidity providers\n    error NoLiquidityToReceiveFees();\n\n    /// Each uint24 variable packs both the swap fees and the withdraw fees represented as integer denominators (1/x). The upper 12 bits are the swap fees, and the lower 12 bits\n    /// are the withdraw fees. For swap fees, the upper 6 bits are the fee for trading 1 for 0, and the lower 6 are for 0 for 1 and are taken as a percentage of the lp swap fee.\n    /// For withdraw fees the upper 6 bits are the fee on amount1, and the lower 6 are for amount0 and are taken as a percentage of the principle amount of the underlying position.\n    /// bits          24 22 20 18 16 14 12 10 8  6  4  2  0\n    ///               |    swapFees     |   withdrawFees  |\n    ///               ┌────────┬────────┬────────┬────────┐\n    /// protocolFees: | 1->0   |  0->1  |  fee1  |  fee0  |\n    /// hookFees:     | 1->0   |  0->1  |  fee1  |  fee0  |\n    ///               └────────┴────────┴────────┴────────┘\n    struct Slot0 {\n        // the current price\n        uint160 sqrtPriceX96;\n        // the current tick\n        int24 tick;\n        uint24 protocolFees;\n        uint24 hookFees;\n        // used for the swap fee, either static at initialize or dynamic via hook\n        uint24 swapFee;\n    }\n\n    // info stored for each initialized individual tick\n    struct TickInfo {\n        // the total position liquidity that references this tick\n        uint128 liquidityGross;\n        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n        int128 liquidityNet;\n        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n        // only has relative meaning, not absolute — the value depends on when the tick is initialized\n        uint256 feeGrowthOutside0X128;\n        uint256 feeGrowthOutside1X128;\n    }\n\n    /// @dev The state of a pool\n    struct State {\n        Slot0 slot0;\n        uint256 feeGrowthGlobal0X128;\n        uint256 feeGrowthGlobal1X128;\n        uint128 liquidity;\n        mapping(int24 => TickInfo) ticks;\n        mapping(int16 => uint256) tickBitmap;\n        mapping(bytes32 => Position.Info) positions;\n    }\n\n    /// @dev Common checks for valid tick inputs.\n    function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n        if (tickLower >= tickUpper)\n            revert TicksMisordered(tickLower, tickUpper);\n        if (tickLower < TickMath.MIN_TICK)\n            revert TickLowerOutOfBounds(tickLower);\n        if (tickUpper > TickMath.MAX_TICK)\n            revert TickUpperOutOfBounds(tickUpper);\n    }\n\n    function initialize(\n        State storage self,\n        uint160 sqrtPriceX96,\n        uint24 protocolFees,\n        uint24 hookFees,\n        uint24 swapFee\n    ) internal returns (int24 tick) {\n        if (self.slot0.sqrtPriceX96 != 0) revert PoolAlreadyInitialized();\n\n        tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n        self.slot0 = Slot0({\n            sqrtPriceX96: sqrtPriceX96,\n            tick: tick,\n            protocolFees: protocolFees,\n            hookFees: hookFees,\n            swapFee: swapFee\n        });\n    }\n\n    function getSwapFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage >> 12);\n    }\n\n    function getWithdrawFee(uint24 feesStorage) internal pure returns (uint16) {\n        return uint16(feesStorage & 0xFFF);\n    }\n\n    function setProtocolFees(State storage self, uint24 protocolFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.protocolFees = protocolFees;\n    }\n\n    function setHookFees(State storage self, uint24 hookFees) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        self.slot0.hookFees = hookFees;\n    }\n\n    /// @notice Only dynamic fee pools may update the swap fee.\n    function setSwapFee(State storage self, uint24 swapFee) internal {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n        self.slot0.swapFee = swapFee;\n    }\n\n    struct ModifyPositionParams {\n        // the address that owns the position\n        address owner;\n        // the lower and upper tick of the position\n        int24 tickLower;\n        int24 tickUpper;\n        // any change in liquidity\n        int128 liquidityDelta;\n        // the spacing between ticks\n        int24 tickSpacing;\n    }\n\n    struct ModifyPositionState {\n        bool flippedLower;\n        uint128 liquidityGrossAfterLower;\n        bool flippedUpper;\n        uint128 liquidityGrossAfterUpper;\n        uint256 feeGrowthInside0X128;\n        uint256 feeGrowthInside1X128;\n    }\n\n    struct FeeAmounts {\n        uint256 feeForProtocol0;\n        uint256 feeForProtocol1;\n        uint256 feeForHook0;\n        uint256 feeForHook1;\n    }\n\n    /// @dev Effect changes to a position in a pool\n    /// @param params the position details and the change to the position's liquidity to effect\n    /// @return result the deltas of the token balances of the pool\n    function modifyPosition(\n        State storage self,\n        ModifyPositionParams memory params\n    ) internal returns (BalanceDelta result, FeeAmounts memory fees) {\n        if (self.slot0.sqrtPriceX96 == 0) revert PoolNotInitialized();\n\n        checkTicks(params.tickLower, params.tickUpper);\n\n        uint256 feesOwed0;\n        uint256 feesOwed1;\n        {\n            ModifyPositionState memory state;\n            // if we need to update the ticks, do it\n\n            if (params.liquidityDelta != 0) {\n                (\n                    state.flippedLower,\n                    state.liquidityGrossAfterLower\n                ) = updateTick(\n                    self,\n                    params.tickLower,\n                    params.liquidityDelta,\n                    false\n                );\n                (\n                    state.flippedUpper,\n                    state.liquidityGrossAfterUpper\n                ) = updateTick(\n                    self,\n                    params.tickUpper,\n                    params.liquidityDelta,\n                    true\n                );\n\n                if (params.liquidityDelta > 0) {\n                    uint128 maxLiquidityPerTick = tickSpacingToMaxLiquidityPerTick(\n                            params.tickSpacing\n                        );\n                    if (state.liquidityGrossAfterLower > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickLower);\n                    }\n                    if (state.liquidityGrossAfterUpper > maxLiquidityPerTick) {\n                        revert TickLiquidityOverflow(params.tickUpper);\n                    }\n                }\n\n                if (state.flippedLower) {\n                    self.tickBitmap.flipTick(\n                        params.tickLower,\n                        params.tickSpacing\n                    );\n                }\n                if (state.flippedUpper) {\n                    self.tickBitmap.flipTick(\n                        params.tickUpper,\n                        params.tickSpacing\n                    );\n                }\n            }\n\n            (\n                state.feeGrowthInside0X128,\n                state.feeGrowthInside1X128\n            ) = getFeeGrowthInside(self, params.tickLower, params.tickUpper);\n\n            (feesOwed0, feesOwed1) = self\n                .positions\n                .get(params.owner, params.tickLower, params.tickUpper)\n                .update(\n                    params.liquidityDelta,\n                    state.feeGrowthInside0X128,\n                    state.feeGrowthInside1X128\n                );\n\n            // clear any tick data that is no longer needed\n            if (params.liquidityDelta < 0) {\n                if (state.flippedLower) {\n                    clearTick(self, params.tickLower);\n                }\n                if (state.flippedUpper) {\n                    clearTick(self, params.tickUpper);\n                }\n            }\n        }\n\n        if (params.liquidityDelta != 0) {\n            if (self.slot0.tick < params.tickLower) {\n                // current tick is below the passed range; liquidity can only become in range by crossing from left to\n                // right, when we'll need _more_ currency0 (it's becoming more valuable) so user must provide it\n                result =\n                    result +\n                    toBalanceDelta(\n                        SqrtPriceMath\n                            .getAmount0Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128(),\n                        0\n                    );\n            } else if (self.slot0.tick < params.tickUpper) {\n                result =\n                    result +\n                    toBalanceDelta(\n                        SqrtPriceMath\n                            .getAmount0Delta(\n                                self.slot0.sqrtPriceX96,\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128(),\n                        SqrtPriceMath\n                            .getAmount1Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                self.slot0.sqrtPriceX96,\n                                params.liquidityDelta\n                            )\n                            .toInt128()\n                    );\n\n                self.liquidity = params.liquidityDelta < 0\n                    ? self.liquidity - uint128(-params.liquidityDelta)\n                    : self.liquidity + uint128(params.liquidityDelta);\n            } else {\n                // current tick is above the passed range; liquidity can only become in range by crossing from right to\n                // left, when we'll need _more_ currency1 (it's becoming more valuable) so user must provide it\n                result =\n                    result +\n                    toBalanceDelta(\n                        0,\n                        SqrtPriceMath\n                            .getAmount1Delta(\n                                TickMath.getSqrtRatioAtTick(params.tickLower),\n                                TickMath.getSqrtRatioAtTick(params.tickUpper),\n                                params.liquidityDelta\n                            )\n                            .toInt128()\n                    );\n            }\n        }\n\n        if (\n            params.liquidityDelta < 0 && getWithdrawFee(self.slot0.hookFees) > 0\n        ) {\n            // Only take fees if the hook withdraw fee is set and the liquidity is being removed.\n            fees = _calculateExternalFees(self, result);\n\n            // Amounts are balances owed to the pool. When negative, they represent the balance a user can take.\n            // Since protocol and hook fees are extracted on the balance a user can take\n            // they are owed (added) back to the pool where they are kept to be collected by the fee recipients.\n            result =\n                result +\n                toBalanceDelta(\n                    fees.feeForHook0.toInt128() +\n                        fees.feeForProtocol0.toInt128(),\n                    fees.feeForHook1.toInt128() +\n                        fees.feeForProtocol1.toInt128()\n                );\n        }\n\n        // Fees earned from LPing are removed from the pool balance.\n        result =\n            result -\n            toBalanceDelta(feesOwed0.toInt128(), feesOwed1.toInt128());\n    }\n\n    function _calculateExternalFees(\n        State storage self,\n        BalanceDelta result\n    ) internal view returns (FeeAmounts memory fees) {\n        int128 amount0 = result.amount0();\n        int128 amount1 = result.amount1();\n\n        Slot0 memory slot0Cache = self.slot0;\n        uint24 hookFees = slot0Cache.hookFees;\n        uint24 protocolFees = slot0Cache.protocolFees;\n\n        uint16 hookFee0 = getWithdrawFee(hookFees) % 64;\n        uint16 hookFee1 = getWithdrawFee(hookFees) >> 6;\n\n        uint16 protocolFee0 = getWithdrawFee(protocolFees) % 64;\n        uint16 protocolFee1 = getWithdrawFee(protocolFees) >> 6;\n\n        if (amount0 < 0 && hookFee0 > 0) {\n            fees.feeForHook0 = uint128(-amount0) / hookFee0;\n        }\n        if (amount1 < 0 && hookFee1 > 0) {\n            fees.feeForHook1 = uint128(-amount1) / hookFee1;\n        }\n\n        // A protocol fee is only applied if the hook fee is applied.\n        if (protocolFee0 > 0 && fees.feeForHook0 > 0) {\n            fees.feeForProtocol0 = fees.feeForHook0 / protocolFee0;\n            fees.feeForHook0 -= fees.feeForProtocol0;\n        }\n\n        if (protocolFee1 > 0 && fees.feeForHook1 > 0) {\n            fees.feeForProtocol1 = fees.feeForHook1 / protocolFee1;\n            fees.feeForHook1 -= fees.feeForProtocol1;\n        }\n\n        return fees;\n    }\n\n    struct SwapCache {\n        // liquidity at the beginning of the swap\n        uint128 liquidityStart;\n        // the protocol fee for the input token\n        uint16 protocolFee;\n        // the hook fee for the input token\n        uint16 hookFee;\n    }\n\n    // the top level state of the swap, the results of which are recorded in storage at the end\n    struct SwapState {\n        // the amount remaining to be swapped in/out of the input/output asset\n        int256 amountSpecifiedRemaining;\n        // the amount already swapped out/in of the output/input asset\n        int256 amountCalculated;\n        // current sqrt(price)\n        uint160 sqrtPriceX96;\n        // the tick associated with the current price\n        int24 tick;\n        // the global fee growth of the input token\n        uint256 feeGrowthGlobalX128;\n        // the current liquidity in range\n        uint128 liquidity;\n    }\n\n    struct StepComputations {\n        // the price at the beginning of the step\n        uint160 sqrtPriceStartX96;\n        // the next tick to swap to from the current tick in the swap direction\n        int24 tickNext;\n        // whether tickNext is initialized or not\n        bool initialized;\n        // sqrt(price) for the next tick (1/0)\n        uint160 sqrtPriceNextX96;\n        // how much is being swapped in in this step\n        uint256 amountIn;\n        // how much is being swapped out\n        uint256 amountOut;\n        // how much fee is being paid in\n        uint256 feeAmount;\n    }\n\n    struct SwapParams {\n        int24 tickSpacing;\n        bool zeroForOne;\n        int256 amountSpecified;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @dev Executes a swap against the state, and returns the amount deltas of the pool\n    function swap(\n        State storage self,\n        SwapParams memory params\n    )\n        internal\n        returns (\n            BalanceDelta result,\n            uint256 feeForProtocol,\n            uint256 feeForHook,\n            uint24 swapFee,\n            SwapState memory state\n        )\n    {\n        if (params.amountSpecified == 0) revert SwapAmountCannotBeZero();\n\n        Slot0 memory slot0Start = self.slot0;\n        swapFee = slot0Start.swapFee;\n        if (slot0Start.sqrtPriceX96 == 0) revert PoolNotInitialized();\n        if (params.zeroForOne) {\n            if (params.sqrtPriceLimitX96 >= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(\n                    slot0Start.sqrtPriceX96,\n                    params.sqrtPriceLimitX96\n                );\n            }\n            if (params.sqrtPriceLimitX96 <= TickMath.MIN_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        } else {\n            if (params.sqrtPriceLimitX96 <= slot0Start.sqrtPriceX96) {\n                revert PriceLimitAlreadyExceeded(\n                    slot0Start.sqrtPriceX96,\n                    params.sqrtPriceLimitX96\n                );\n            }\n            if (params.sqrtPriceLimitX96 >= TickMath.MAX_SQRT_RATIO) {\n                revert PriceLimitOutOfBounds(params.sqrtPriceLimitX96);\n            }\n        }\n\n        SwapCache memory cache = SwapCache({\n            liquidityStart: self.liquidity,\n            protocolFee: params.zeroForOne\n                ? (getSwapFee(slot0Start.protocolFees) % 64)\n                : (getSwapFee(slot0Start.protocolFees) >> 6),\n            hookFee: params.zeroForOne\n                ? (getSwapFee(slot0Start.hookFees) % 64)\n                : (getSwapFee(slot0Start.hookFees) >> 6)\n        });\n\n        bool exactInput = params.amountSpecified > 0;\n\n        state = SwapState({\n            amountSpecifiedRemaining: params.amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: slot0Start.sqrtPriceX96,\n            tick: slot0Start.tick,\n            feeGrowthGlobalX128: params.zeroForOne\n                ? self.feeGrowthGlobal0X128\n                : self.feeGrowthGlobal1X128,\n            liquidity: cache.liquidityStart\n        });\n\n        StepComputations memory step;\n        // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n        while (\n            state.amountSpecifiedRemaining != 0 &&\n            state.sqrtPriceX96 != params.sqrtPriceLimitX96\n        ) {\n            step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n            (step.tickNext, step.initialized) = self\n                .tickBitmap\n                .nextInitializedTickWithinOneWord(\n                    state.tick,\n                    params.tickSpacing,\n                    params.zeroForOne\n                );\n\n            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n            if (step.tickNext < TickMath.MIN_TICK) {\n                step.tickNext = TickMath.MIN_TICK;\n            } else if (step.tickNext > TickMath.MAX_TICK) {\n                step.tickNext = TickMath.MAX_TICK;\n            }\n\n            // get the price for the next tick\n            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n            (\n                state.sqrtPriceX96,\n                step.amountIn,\n                step.amountOut,\n                step.feeAmount\n            ) = SwapMath.computeSwapStep(\n                state.sqrtPriceX96,\n                (\n                    params.zeroForOne\n                        ? step.sqrtPriceNextX96 < params.sqrtPriceLimitX96\n                        : step.sqrtPriceNextX96 > params.sqrtPriceLimitX96\n                )\n                    ? params.sqrtPriceLimitX96\n                    : step.sqrtPriceNextX96,\n                state.liquidity,\n                state.amountSpecifiedRemaining,\n                swapFee\n            );\n\n            if (exactInput) {\n                // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n                unchecked {\n                    state.amountSpecifiedRemaining -= (step.amountIn +\n                        step.feeAmount).toInt256();\n                }\n                state.amountCalculated =\n                    state.amountCalculated -\n                    step.amountOut.toInt256();\n            } else {\n                unchecked {\n                    state.amountSpecifiedRemaining += step.amountOut.toInt256();\n                }\n                state.amountCalculated =\n                    state.amountCalculated +\n                    (step.amountIn + step.feeAmount).toInt256();\n            }\n\n            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n            if (cache.protocolFee > 0) {\n                // A: calculate the amount of the fee that should go to the protocol\n                uint256 delta = step.feeAmount / cache.protocolFee;\n                // A: subtract it from the regular fee and add it to the protocol fee\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForProtocol += delta;\n                }\n            }\n\n            if (cache.hookFee > 0) {\n                // step.feeAmount has already been updated to account for the protocol fee\n                uint256 delta = step.feeAmount / cache.hookFee;\n                unchecked {\n                    step.feeAmount -= delta;\n                    feeForHook += delta;\n                }\n            }\n\n            // update global fee tracker\n            if (state.liquidity > 0) {\n                unchecked {\n                    state.feeGrowthGlobalX128 += FullMath.mulDiv(\n                        step.feeAmount,\n                        FixedPoint128.Q128,\n                        state.liquidity\n                    );\n                }\n            }\n\n            // shift tick if we reached the next price\n            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n                // if the tick is initialized, run the tick transition\n                if (step.initialized) {\n                    int128 liquidityNet = Pool.crossTick(\n                        self,\n                        step.tickNext,\n                        (\n                            params.zeroForOne\n                                ? state.feeGrowthGlobalX128\n                                : self.feeGrowthGlobal0X128\n                        ),\n                        (\n                            params.zeroForOne\n                                ? self.feeGrowthGlobal1X128\n                                : state.feeGrowthGlobalX128\n                        )\n                    );\n                    // if we're moving leftward, we interpret liquidityNet as the opposite sign\n                    // safe because liquidityNet cannot be type(int128).min\n                    unchecked {\n                        if (params.zeroForOne) liquidityNet = -liquidityNet;\n                    }\n\n                    state.liquidity = liquidityNet < 0\n                        ? state.liquidity - uint128(-liquidityNet)\n                        : state.liquidity + uint128(liquidityNet);\n                }\n\n                unchecked {\n                    state.tick = params.zeroForOne\n                        ? step.tickNext - 1\n                        : step.tickNext;\n                }\n            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n                // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n            }\n        }\n\n        (self.slot0.sqrtPriceX96, self.slot0.tick) = (\n            state.sqrtPriceX96,\n            state.tick\n        );\n\n        // update liquidity if it changed\n        if (cache.liquidityStart != state.liquidity)\n            self.liquidity = state.liquidity;\n\n        // update fee growth global\n        if (params.zeroForOne) {\n            self.feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n        } else {\n            self.feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n        }\n\n        unchecked {\n            if (params.zeroForOne == exactInput) {\n                result = toBalanceDelta(\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\n                        .toInt128(),\n                    state.amountCalculated.toInt128()\n                );\n            } else {\n                result = toBalanceDelta(\n                    state.amountCalculated.toInt128(),\n                    (params.amountSpecified - state.amountSpecifiedRemaining)\n                        .toInt128()\n                );\n            }\n        }\n    }\n\n    /// @notice Donates the given amount of currency0 and currency1 to the pool\n    function donate(\n        State storage state,\n        uint256 amount0,\n        uint256 amount1\n    ) internal returns (BalanceDelta delta) {\n        if (state.liquidity == 0) revert NoLiquidityToReceiveFees();\n        delta = toBalanceDelta(amount0.toInt128(), amount1.toInt128());\n        unchecked {\n            if (amount0 > 0) {\n                state.feeGrowthGlobal0X128 += FullMath.mulDiv(\n                    amount0,\n                    FixedPoint128.Q128,\n                    state.liquidity\n                );\n            }\n            if (amount1 > 0) {\n                state.feeGrowthGlobal1X128 += FullMath.mulDiv(\n                    amount1,\n                    FixedPoint128.Q128,\n                    state.liquidity\n                );\n            }\n        }\n    }\n\n    /// @notice Retrieves fee growth data\n    /// @param self The Pool state struct\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n    function getFeeGrowthInside(\n        State storage self,\n        int24 tickLower,\n        int24 tickUpper\n    )\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        TickInfo storage lower = self.ticks[tickLower];\n        TickInfo storage upper = self.ticks[tickUpper];\n        int24 tickCurrent = self.slot0.tick;\n\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 =\n                    lower.feeGrowthOutside0X128 -\n                    upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    lower.feeGrowthOutside1X128 -\n                    upper.feeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 =\n                    upper.feeGrowthOutside0X128 -\n                    lower.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    upper.feeGrowthOutside1X128 -\n                    lower.feeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 =\n                    self.feeGrowthGlobal0X128 -\n                    lower.feeGrowthOutside0X128 -\n                    upper.feeGrowthOutside0X128;\n                feeGrowthInside1X128 =\n                    self.feeGrowthGlobal1X128 -\n                    lower.feeGrowthOutside1X128 -\n                    upper.feeGrowthOutside1X128;\n            }\n        }\n    }\n\n    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n    /// @param self The mapping containing all tick information for initialized ticks\n    /// @param tick The tick that will be updated\n    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n    /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n    /// @return liquidityGrossAfter The total amount of  liquidity for all positions that references the tick after the update\n    function updateTick(\n        State storage self,\n        int24 tick,\n        int128 liquidityDelta,\n        bool upper\n    ) internal returns (bool flipped, uint128 liquidityGrossAfter) {\n        TickInfo storage info = self.ticks[tick];\n\n        uint128 liquidityGrossBefore;\n        int128 liquidityNetBefore;\n        assembly {\n            // load first slot of info which contains liquidityGross and liquidityNet packed\n            // where the top 128 bits are liquidityNet and the bottom 128 bits are liquidityGross\n            let liquidity := sload(info.slot)\n            // slice off top 128 bits of liquidity (liquidityNet) to get just liquidityGross\n            liquidityGrossBefore := shr(128, shl(128, liquidity))\n            // shift right 128 bits to get just liquidityNet\n            liquidityNetBefore := shr(128, liquidity)\n        }\n\n        liquidityGrossAfter = liquidityDelta < 0\n            ? liquidityGrossBefore - uint128(-liquidityDelta)\n            : liquidityGrossBefore + uint128(liquidityDelta);\n\n        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n        if (liquidityGrossBefore == 0) {\n            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n            if (tick <= self.slot0.tick) {\n                info.feeGrowthOutside0X128 = self.feeGrowthGlobal0X128;\n                info.feeGrowthOutside1X128 = self.feeGrowthGlobal1X128;\n            }\n        }\n\n        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n        int128 liquidityNet = upper\n            ? liquidityNetBefore - liquidityDelta\n            : liquidityNetBefore + liquidityDelta;\n        assembly {\n            // liquidityGrossAfter and liquidityNet are packed in the first slot of `info`\n            // So we can store them with a single sstore by packing them ourselves first\n            sstore(\n                info.slot,\n                // bitwise OR to pack liquidityGrossAfter and liquidityNet\n                or(\n                    // liquidityGross is in the low bits, upper bits are already 0\n                    liquidityGrossAfter,\n                    // shift liquidityNet to take the upper bits and lower bits get filled with 0\n                    shl(128, liquidityNet)\n                )\n            )\n        }\n    }\n\n    /// @notice Derives max liquidity per tick from given tick spacing\n    /// @dev Executed within the pool constructor\n    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n    /// @return The max liquidity per tick\n    function tickSpacingToMaxLiquidityPerTick(\n        int24 tickSpacing\n    ) internal pure returns (uint128) {\n        unchecked {\n            return\n                uint128(\n                    (type(uint128).max * uint256(int256(tickSpacing))) /\n                        uint256(int256(TickMath.MAX_TICK * 2 + tickSpacing))\n                );\n        }\n    }\n\n    /// @notice Clears tick data\n    /// @param self The mapping containing all initialized tick information for initialized ticks\n    /// @param tick The tick that will be cleared\n    function clearTick(State storage self, int24 tick) internal {\n        delete self.ticks[tick];\n    }\n\n    /// @notice Transitions to next tick as needed by price movement\n    /// @param self The Pool state struct\n    /// @param tick The destination tick of the transition\n    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n    function crossTick(\n        State storage self,\n        int24 tick,\n        uint256 feeGrowthGlobal0X128,\n        uint256 feeGrowthGlobal1X128\n    ) internal returns (int128 liquidityNet) {\n        unchecked {\n            TickInfo storage info = self.ticks[tick];\n            info.feeGrowthOutside0X128 =\n                feeGrowthGlobal0X128 -\n                info.feeGrowthOutside0X128;\n            info.feeGrowthOutside1X128 =\n                feeGrowthGlobal1X128 -\n                info.feeGrowthOutside1X128;\n            liquidityNet = info.liquidityNet;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint128} from \"./FixedPoint128.sol\";\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n    /// @notice Cannot update a position with no liquidity\n    error CannotUpdateEmptyPosition();\n\n    // info stored for each user's position\n    struct Info {\n        // the amount of liquidity owned by this position\n        uint128 liquidity;\n        // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n        uint256 feeGrowthInside0LastX128;\n        uint256 feeGrowthInside1LastX128;\n    }\n\n    /// @notice Returns the Info struct of a position, given an owner and position boundaries\n    /// @param self The mapping containing all user positions\n    /// @param owner The address of the position owner\n    /// @param tickLower The lower tick boundary of the position\n    /// @param tickUpper The upper tick boundary of the position\n    /// @return position The position info struct of the given owners' position\n    function get(mapping(bytes32 => Info) storage self, address owner, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (Position.Info storage position)\n    {\n        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n    }\n\n    /// @notice Credits accumulated fees to a user's position\n    /// @param self The individual position to update\n    /// @param liquidityDelta The change in pool liquidity as a result of the position update\n    /// @param feeGrowthInside0X128 The all-time fee growth in currency0, per unit of liquidity, inside the position's tick boundaries\n    /// @param feeGrowthInside1X128 The all-time fee growth in currency1, per unit of liquidity, inside the position's tick boundaries\n    /// @return feesOwed0 The amount of currency0 owed to the position owner\n    /// @return feesOwed1 The amount of currency1 owed to the position owner\n    function update(\n        Info storage self,\n        int128 liquidityDelta,\n        uint256 feeGrowthInside0X128,\n        uint256 feeGrowthInside1X128\n    ) internal returns (uint256 feesOwed0, uint256 feesOwed1) {\n        Info memory _self = self;\n\n        uint128 liquidityNext;\n        if (liquidityDelta == 0) {\n            if (_self.liquidity == 0) revert CannotUpdateEmptyPosition(); // disallow pokes for 0 liquidity positions\n            liquidityNext = _self.liquidity;\n        } else {\n            liquidityNext = liquidityDelta < 0\n                ? _self.liquidity - uint128(-liquidityDelta)\n                : _self.liquidity + uint128(liquidityDelta);\n        }\n\n        // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n        unchecked {\n            feesOwed0 = FullMath.mulDiv(\n                feeGrowthInside0X128 - _self.feeGrowthInside0LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n            feesOwed1 = FullMath.mulDiv(\n                feeGrowthInside1X128 - _self.feeGrowthInside1LastX128, _self.liquidity, FixedPoint128.Q128\n            );\n        }\n\n        // update the position\n        if (liquidityDelta != 0) self.liquidity = liquidityNext;\n        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y <= uint256(type(int256).max));\n        z = int256(y);\n    }\n\n    /// @notice Cast a uint256 to a int128, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(uint256 y) internal pure returns (int128 z) {\n        require(y <= uint128(type(int128).max));\n        z = int128(int256(y));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {UnsafeMath} from \"./UnsafeMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of currency0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the currency0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of currency0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            unchecked {\n                uint256 product;\n                if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                    uint256 denominator = numerator1 + product;\n                    if (denominator >= numerator1) {\n                        // always fits in 160 bits\n                        return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n                    }\n                }\n            }\n            // denominator is checked for overflow\n            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n        } else {\n            unchecked {\n                uint256 product;\n                // if the product overflows, we know the denominator underflows\n                // in addition, we must check that the denominator does not underflow\n                require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n                uint256 denominator = numerator1 - product;\n                return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n            }\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of currency1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the currency1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of currency1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of currency1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(uint160 sqrtPX96, uint128 liquidity, uint256 amount, bool add)\n        internal\n        pure\n        returns (uint160)\n    {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return (uint256(sqrtPX96) + quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n                    : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of currency0, or currency1, is being swapped in\n    /// @param zeroForOne Whether the amount in is currency0 or currency1\n    /// @return sqrtQX96 The price after adding the input amount to currency0 or currency1\n    function getNextSqrtPriceFromInput(uint160 sqrtPX96, uint128 liquidity, uint256 amountIn, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n            : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of currency0 or currency1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of currency0, or currency1, is being swapped out\n    /// @param zeroForOne Whether the amount out is currency0 or currency1\n    /// @return sqrtQX96 The price after removing the output amount of currency0 or currency1\n    function getNextSqrtPriceFromOutput(uint160 sqrtPX96, uint128 liquidity, uint256 amountOut, bool zeroForOne)\n        internal\n        pure\n        returns (uint160 sqrtQX96)\n    {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return zeroForOne\n            ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n            : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of currency0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount0)\n    {\n        unchecked {\n            if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n            uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n            uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n            require(sqrtRatioAX96 > 0);\n\n            return roundUp\n                ? UnsafeMath.divRoundingUp(FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96), sqrtRatioAX96)\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n        }\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of currency1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity, bool roundUp)\n        internal\n        pure\n        returns (uint256 amount1)\n    {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return roundUp\n            ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n            : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Helper that gets signed currency0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of currency0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount0)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n\n    /// @notice Helper that gets signed currency1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of currency1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, int128 liquidity)\n        internal\n        pure\n        returns (int256 amount1)\n    {\n        unchecked {\n            return liquidity < 0\n                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()\n                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/StateLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolId} from \"../types/PoolId.sol\";\nimport {IPoolManager} from \"../interfaces/IPoolManager.sol\";\nimport {Currency} from \"../types/Currency.sol\";\nimport {Position} from \"./Position.sol\";\n\nlibrary StateLibrary {\n    // forge inspect src/PoolManager.sol:PoolManager storage --pretty\n    // | Name                  | Type                                    | Slot | Offset | Bytes | Contract                        |\n    // |-----------------------|-----------------------------------------|------|--------|-------|---------------------------------|\n    // | pools                 | mapping(PoolId => struct Pool.State)    | 6    | 0      | 32    | src/PoolManager.sol:PoolManager |\n    bytes32 public constant POOLS_SLOT = bytes32(uint256(6));\n\n    // index of feeGrowthGlobal0X128 in Pool.State\n    uint256 public constant FEE_GROWTH_GLOBAL0_OFFSET = 1;\n    // index of feeGrowthGlobal1X128 in Pool.State\n    uint256 public constant FEE_GROWTH_GLOBAL1_OFFSET = 2;\n\n    // index of liquidity in Pool.State\n    uint256 public constant LIQUIDITY_OFFSET = 3;\n\n    // index of TicksInfo mapping in Pool.State: mapping(int24 => TickInfo) ticks;\n    uint256 public constant TICKS_OFFSET = 4;\n\n    // index of tickBitmap mapping in Pool.State\n    uint256 public constant TICK_BITMAP_OFFSET = 5;\n\n    // index of Position.Info mapping in Pool.State: mapping(bytes32 => Position.Info) positions;\n    uint256 public constant POSITIONS_OFFSET = 6;\n\n    /**\n     * @notice Get Slot0 of the pool: sqrtPriceX96, tick, protocolFee, lpFee\n     * @dev Corresponds to pools[poolId].slot0\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return sqrtPriceX96 The square root of the price of the pool, in Q96 precision.\n     * @return tick The current tick of the pool.\n     * @return protocolFee The protocol fee of the pool.\n     * @return lpFee The swap fee of the pool.\n     */\n    function getSlot0(IPoolManager manager, PoolId poolId)\n        internal\n        view\n        returns (uint160 sqrtPriceX96, int24 tick, uint24 protocolFee, uint24 lpFee)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        bytes32 data = manager.extsload(stateSlot);\n\n        //   24 bits  |24bits|24bits      |24 bits|160 bits\n        // 0x000000   |000bb8|000000      |ffff75 |0000000000000000fe3aa841ba359daa0ea9eff7\n        // ---------- | fee  |protocolfee | tick  | sqrtPriceX96\n        assembly {\n            // bottom 160 bits of data\n            sqrtPriceX96 := and(data, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            // next 24 bits of data\n            tick := signextend(2, shr(160, data))\n            // next 24 bits of data\n            protocolFee := and(shr(184, data), 0xFFFFFF)\n            // last 24 bits of data\n            lpFee := and(shr(208, data), 0xFFFFFF)\n        }\n    }\n\n    /**\n     * @notice Retrieves the tick information of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].ticks[tick]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve information for.\n     * @return liquidityGross The total position liquidity that references this tick\n     * @return liquidityNet The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)\n     * @return feeGrowthOutside0X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     * @return feeGrowthOutside1X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     */\n    function getTickInfo(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128\n        )\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        // read all 3 words of the TickInfo struct\n        bytes memory data = manager.extsload(slot, 3);\n        assembly {\n            let firstWord := mload(add(data, 32))\n            liquidityNet := sar(128, firstWord)\n            liquidityGross := and(firstWord, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n            feeGrowthOutside0X128 := mload(add(data, 64))\n            feeGrowthOutside1X128 := mload(add(data, 96))\n        }\n    }\n\n    /**\n     * @notice Retrieves the liquidity information of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].ticks[tick].liquidityGross and pools[poolId].ticks[tick].liquidityNet. A more gas efficient version of getTickInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve liquidity for.\n     * @return liquidityGross The total position liquidity that references this tick\n     * @return liquidityNet The amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left)\n     */\n    function getTickLiquidity(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (uint128 liquidityGross, int128 liquidityNet)\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        bytes32 value = manager.extsload(slot);\n        assembly {\n            liquidityNet := sar(128, value)\n            liquidityGross := and(value, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        }\n    }\n\n    /**\n     * @notice Retrieves the fee growth outside a tick range of a pool\n     * @dev Corresponds to pools[poolId].ticks[tick].feeGrowthOutside0X128 and pools[poolId].ticks[tick].feeGrowthOutside1X128. A more gas efficient version of getTickInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve fee growth for.\n     * @return feeGrowthOutside0X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     * @return feeGrowthOutside1X128 fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n     */\n    function getTickFeeGrowthOutside(IPoolManager manager, PoolId poolId, int24 tick)\n        internal\n        view\n        returns (uint256 feeGrowthOutside0X128, uint256 feeGrowthOutside1X128)\n    {\n        bytes32 slot = _getTickInfoSlot(poolId, tick);\n\n        // offset by 1 word, since the first word is liquidityGross + liquidityNet\n        bytes memory data = manager.extsload(bytes32(uint256(slot) + 1), 2);\n        assembly {\n            feeGrowthOutside0X128 := mload(add(data, 32))\n            feeGrowthOutside1X128 := mload(add(data, 64))\n        }\n    }\n\n    /**\n     * @notice Retrieves the global fee growth of a pool.\n     * @dev Corresponds to pools[poolId].feeGrowthGlobal0X128 and pools[poolId].feeGrowthGlobal1X128\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return feeGrowthGlobal0 The global fee growth for token0.\n     * @return feeGrowthGlobal1 The global fee growth for token1.\n     */\n    function getFeeGrowthGlobals(IPoolManager manager, PoolId poolId)\n        internal\n        view\n        returns (uint256 feeGrowthGlobal0, uint256 feeGrowthGlobal1)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State, `uint256 feeGrowthGlobal0X128`\n        bytes32 slot_feeGrowthGlobal0X128 = bytes32(uint256(stateSlot) + FEE_GROWTH_GLOBAL0_OFFSET);\n\n        // read the 2 words of feeGrowthGlobal\n        bytes memory data = manager.extsload(slot_feeGrowthGlobal0X128, 2);\n        assembly {\n            feeGrowthGlobal0 := mload(add(data, 32))\n            feeGrowthGlobal1 := mload(add(data, 64))\n        }\n    }\n\n    /**\n     * @notice Retrieves total the liquidity of a pool.\n     * @dev Corresponds to pools[poolId].liquidity\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @return liquidity The liquidity of the pool.\n     */\n    function getLiquidity(IPoolManager manager, PoolId poolId) internal view returns (uint128 liquidity) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `uint128 liquidity`\n        bytes32 slot = bytes32(uint256(stateSlot) + LIQUIDITY_OFFSET);\n\n        liquidity = uint128(uint256(manager.extsload(slot)));\n    }\n\n    /**\n     * @notice Retrieves the tick bitmap of a pool at a specific tick.\n     * @dev Corresponds to pools[poolId].tickBitmap[tick]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tick The tick to retrieve the bitmap for.\n     * @return tickBitmap The bitmap of the tick.\n     */\n    function getTickBitmap(IPoolManager manager, PoolId poolId, int16 tick)\n        internal\n        view\n        returns (uint256 tickBitmap)\n    {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(int16 => uint256) tickBitmap;`\n        bytes32 tickBitmapMapping = bytes32(uint256(stateSlot) + TICK_BITMAP_OFFSET);\n\n        // slot id of the mapping key: `pools[poolId].tickBitmap[tick]\n        bytes32 slot = keccak256(abi.encodePacked(int256(tick), tickBitmapMapping));\n\n        tickBitmap = uint256(manager.extsload(slot));\n    }\n\n    /**\n     * @notice Retrieves the position information of a pool at a specific position ID.\n     * @dev Corresponds to pools[poolId].positions[positionId]\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param positionId The ID of the position.\n     * @return liquidity The liquidity of the position.\n     * @return feeGrowthInside0LastX128 The fee growth inside the position for token0.\n     * @return feeGrowthInside1LastX128 The fee growth inside the position for token1.\n     */\n    function getPositionInfo(IPoolManager manager, PoolId poolId, bytes32 positionId)\n        internal\n        view\n        returns (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128)\n    {\n        bytes32 slot = _getPositionInfoSlot(poolId, positionId);\n\n        // read all 3 words of the Position.Info struct\n        bytes memory data = manager.extsload(slot, 3);\n\n        assembly {\n            liquidity := mload(add(data, 32))\n            feeGrowthInside0LastX128 := mload(add(data, 64))\n            feeGrowthInside1LastX128 := mload(add(data, 96))\n        }\n    }\n\n    function getPosition(\n        IPoolManager manager,\n        PoolId poolId,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper,\n        bytes32 salt\n    ) internal view returns (Position.Info memory) {\n        // positionKey = keccak256(abi.encodePacked(owner, tickLower, tickUpper, salt))\n        bytes32 positionKey;\n\n        assembly (\"memory-safe\") {\n            mstore(0x26, salt) // [0x26, 0x46)\n            mstore(0x06, tickUpper) // [0x23, 0x26)\n            mstore(0x03, tickLower) // [0x20, 0x23)\n            mstore(0, owner) // [0x0c, 0x20)\n            positionKey := keccak256(0x0c, 0x3a) // len is 58 bytes\n            mstore(0x26, 0) // rewrite 0x26 to 0\n        }\n        (uint128 liquidity, uint256 feeGrowthInside0LastX128, uint256 feeGrowthInside1LastX128) =\n            getPositionInfo(manager, poolId, positionKey);\n        return Position.Info({\n            liquidity: liquidity,\n            feeGrowthInside0LastX128: feeGrowthInside0LastX128,\n            feeGrowthInside1LastX128: feeGrowthInside1LastX128\n        });\n    }\n\n    /**\n     * @notice Retrieves the liquidity of a position.\n     * @dev Corresponds to pools[poolId].positions[positionId].liquidity. A more gas efficient version of getPositionInfo\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param positionId The ID of the position.\n     * @return liquidity The liquidity of the position.\n     */\n    function getPositionLiquidity(IPoolManager manager, PoolId poolId, bytes32 positionId)\n        internal\n        view\n        returns (uint128 liquidity)\n    {\n        bytes32 slot = _getPositionInfoSlot(poolId, positionId);\n        liquidity = uint128(uint256(manager.extsload(slot)));\n    }\n\n    /**\n     * @notice Live calculate the fee growth inside a tick range of a pool\n     * @dev pools[poolId].feeGrowthInside0LastX128 in Position.Info is cached and can become stale. This function will live calculate the feeGrowthInside\n     * @param manager The pool manager contract.\n     * @param poolId The ID of the pool.\n     * @param tickLower The lower tick of the range.\n     * @param tickUpper The upper tick of the range.\n     * @return feeGrowthInside0X128 The fee growth inside the tick range for token0.\n     * @return feeGrowthInside1X128 The fee growth inside the tick range for token1.\n     */\n    function getFeeGrowthInside(IPoolManager manager, PoolId poolId, int24 tickLower, int24 tickUpper)\n        internal\n        view\n        returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128)\n    {\n        (uint256 feeGrowthGlobal0X128, uint256 feeGrowthGlobal1X128) = getFeeGrowthGlobals(manager, poolId);\n\n        (uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128) =\n            getTickFeeGrowthOutside(manager, poolId, tickLower);\n        (uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128) =\n            getTickFeeGrowthOutside(manager, poolId, tickUpper);\n        (, int24 tickCurrent,,) = getSlot0(manager, poolId);\n        unchecked {\n            if (tickCurrent < tickLower) {\n                feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            } else if (tickCurrent >= tickUpper) {\n                feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n            } else {\n                feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n                feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n            }\n        }\n    }\n\n    function _getPoolStateSlot(PoolId poolId) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(PoolId.unwrap(poolId), POOLS_SLOT));\n    }\n\n    function _getTickInfoSlot(PoolId poolId, int24 tick) internal pure returns (bytes32) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(int24 => TickInfo) ticks`\n        bytes32 ticksMappingSlot = bytes32(uint256(stateSlot) + TICKS_OFFSET);\n\n        // slot key of the tick key: `pools[poolId].ticks[tick]\n        return keccak256(abi.encodePacked(int256(tick), ticksMappingSlot));\n    }\n\n    function _getPositionInfoSlot(PoolId poolId, bytes32 positionId) internal pure returns (bytes32 slot) {\n        // slot key of Pool.State value: `pools[poolId]`\n        bytes32 stateSlot = _getPoolStateSlot(poolId);\n\n        // Pool.State: `mapping(bytes32 => Position.Info) positions;`\n        bytes32 positionMapping = bytes32(uint256(stateSlot) + POSITIONS_OFFSET);\n\n        // slot of the mapping key: `pools[poolId].positions[positionId]\n        return keccak256(abi.encodePacked(positionId, positionMapping));\n    }\n}"
    },
    "contracts/Uniswap/V4-Core/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {SqrtPriceMath} from \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either currency0 or currency1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either currency0 or currency1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    ) internal pure returns (uint160 sqrtRatioNextX96, uint256 amountIn, uint256 amountOut, uint256 feeAmount) {\n        unchecked {\n            bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n            bool exactIn = amountRemaining >= 0;\n\n            if (exactIn) {\n                uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n                amountIn = zeroForOne\n                    ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n                if (amountRemainingLessFee >= amountIn) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                        sqrtRatioCurrentX96, liquidity, amountRemainingLessFee, zeroForOne\n                    );\n                }\n            } else {\n                amountOut = zeroForOne\n                    ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n                if (uint256(-amountRemaining) >= amountOut) {\n                    sqrtRatioNextX96 = sqrtRatioTargetX96;\n                } else {\n                    sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                        sqrtRatioCurrentX96, liquidity, uint256(-amountRemaining), zeroForOne\n                    );\n                }\n            }\n\n            bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n            // get the input/output amounts\n            if (zeroForOne) {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n            } else {\n                amountIn = max && exactIn\n                    ? amountIn\n                    : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n                amountOut = max && !exactIn\n                    ? amountOut\n                    : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n            }\n\n            // cap the output amount to not exceed the remaining output amount\n            if (!exactIn && amountOut > uint256(-amountRemaining)) {\n                amountOut = uint256(-amountRemaining);\n            }\n\n            if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n                // we didn't reach the target, so take the remainder of the maximum input as fee\n                feeAmount = uint256(amountRemaining) - amountIn;\n            } else {\n                feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n    /// @notice Thrown when the tick is not enumerated by the tick spacing\n    /// @param tick the invalid tick\n    /// @param tickSpacing The tick spacing of the pool\n    error TickMisaligned(int24 tick, int24 tickSpacing);\n\n    /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n    /// @param tick The tick for which to compute the position\n    /// @return wordPos The key in the mapping containing the word in which the bit is stored\n    /// @return bitPos The bit position in the word where the flag is stored\n    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n        unchecked {\n            wordPos = int16(tick >> 8);\n            bitPos = uint8(int8(tick % 256));\n        }\n    }\n\n    /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n    /// @param self The mapping in which to flip the tick\n    /// @param tick The tick to flip\n    /// @param tickSpacing The spacing between usable ticks\n    function flipTick(mapping(int16 => uint256) storage self, int24 tick, int24 tickSpacing) internal {\n        unchecked {\n            if (tick % tickSpacing != 0) revert TickMisaligned(tick, tickSpacing); // ensure that the tick is spaced\n            (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n            uint256 mask = 1 << bitPos;\n            self[wordPos] ^= mask;\n        }\n    }\n\n    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n    /// to the left (less than or equal to) or right (greater than) of the given tick\n    /// @param self The mapping in which to compute the next initialized tick\n    /// @param tick The starting tick\n    /// @param tickSpacing The spacing between usable ticks\n    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n    function nextInitializedTickWithinOneWord(\n        mapping(int16 => uint256) storage self,\n        int24 tick,\n        int24 tickSpacing,\n        bool lte\n    ) internal view returns (int24 next, bool initialized) {\n        unchecked {\n            int24 compressed = tick / tickSpacing;\n            if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity\n\n            if (lte) {\n                (int16 wordPos, uint8 bitPos) = position(compressed);\n                // all the 1s at or to the right of the current bitPos\n                uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n                    : (compressed - int24(uint24(bitPos))) * tickSpacing;\n            } else {\n                // start from the word of the next tick, since the current tick state doesn't matter\n                (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n                // all the 1s at or to the left of the bitPos\n                uint256 mask = ~((1 << bitPos) - 1);\n                uint256 masked = self[wordPos] & mask;\n\n                // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n                initialized = masked != 0;\n                // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n                next = initialized\n                    ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n                    : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @notice Thrown when the tick passed to #getSqrtRatioAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick();\n    /// @notice Thrown when the ratio passed to #getTickAtSqrtRatio does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtRatio();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert InvalidTick();\n\n            uint256 ratio =\n                absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (sqrtPriceX96 < MIN_SQRT_RATIO || sqrtPriceX96 >= MAX_SQRT_RATIO) revert InvalidSqrtRatio();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.20;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(\n        uint256 x,\n        uint256 y\n    ) internal pure returns (uint256 z) {\n        unchecked {\n            assembly {\n                z := add(div(x, y), gt(mod(x, y), 0))\n            }\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/NoDelegateCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\nabstract contract NoDelegateCall {\n    error DelegateCallNotAllowed();\n\n    /// @dev The original address of this contract\n    address private immutable original;\n\n    constructor() {\n        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n        // In other words, this variable won't change when it's checked at runtime.\n        original = address(this);\n    }\n\n    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\n    function checkNotDelegateCall() private view {\n        if (address(this) != original) revert DelegateCallNotAllowed();\n    }\n\n    /// @notice Prevents delegatecall into the modified method\n    modifier noDelegateCall() {\n        checkNotDelegateCall();\n        _;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/Owned.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\ncontract Owned {\n    address public owner;\n    bytes12 private STORAGE_PLACEHOLDER;\n\n    error InvalidCaller();\n\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert InvalidCaller();\n        _;\n    }\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnerChanged(address(0), msg.sender);\n    }\n\n    function setOwner(address _owner) external onlyOwner {\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/PoolManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.20;\n\nimport {Hooks} from \"./libraries/Hooks.sol\";\nimport {Pool} from \"./libraries/Pool.sol\";\nimport {SafeCast} from \"./libraries/SafeCast.sol\";\nimport {Position} from \"./libraries/Position.sol\";\nimport {FeeLibrary} from \"./libraries/FeeLibrary.sol\";\nimport {Currency, CurrencyLibrary} from \"./types/Currency.sol\";\nimport {PoolKey} from \"./types/PoolKey.sol\";\nimport {LockDataLibrary} from \"./libraries/LockDataLibrary.sol\";\nimport {NoDelegateCall} from \"./NoDelegateCall.sol\";\nimport {Owned} from \"./Owned.sol\";\nimport {IHooks} from \"./interfaces/IHooks.sol\";\nimport {IDynamicFeeManager} from \"./interfaces/IDynamicFeeManager.sol\";\nimport {IHookFeeManager} from \"./interfaces/IHookFeeManager.sol\";\nimport {IPoolManager} from \"./interfaces/IPoolManager.sol\";\nimport {ILockCallback} from \"./interfaces/callback/ILockCallback.sol\";\nimport {Fees} from \"./Fees.sol\";\nimport {Claims} from \"./Claims.sol\";\nimport {PoolId, PoolIdLibrary} from \"./types/PoolId.sol\";\nimport {BalanceDelta} from \"./types/BalanceDelta.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Holds the state for all pools\ncontract PoolManager is IPoolManager, Fees, NoDelegateCall, Claims {\n    using PoolIdLibrary for PoolKey;\n    using SafeCast for *;\n    using Pool for *;\n    using Hooks for IHooks;\n    using Position for mapping(bytes32 => Position.Info);\n    using CurrencyLibrary for Currency;\n    using LockDataLibrary for IPoolManager.LockData;\n    using FeeLibrary for uint24;\n\n    /// @inheritdoc IPoolManager\n    int24 public constant override MAX_TICK_SPACING = type(int16).max;\n\n    /// @inheritdoc IPoolManager\n    int24 public constant override MIN_TICK_SPACING = 1;\n\n    /// @inheritdoc IPoolManager\n    IPoolManager.LockData public override lockData;\n\n    /// @dev Represents the currencies due/owed to each locker.\n    /// Must all net to zero when the last lock is released.\n    mapping(address locker => mapping(Currency currency => int256 currencyDelta))\n        public currencyDelta;\n\n    /// @inheritdoc IPoolManager\n    mapping(Currency currency => uint256) public override reservesOf;\n\n    mapping(PoolId id => Pool.State) public pools;\n\n    constructor(uint256 controllerGasLimit) Fees(controllerGasLimit) {}\n\n    function _getPool(\n        PoolKey memory key\n    ) private view returns (Pool.State storage) {\n        return pools[key.toId()];\n    }\n\n    /// @inheritdoc IPoolManager\n    function getSlot0(\n        PoolId id\n    )\n        external\n        view\n        override\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint24 protocolFees,\n            uint24 hookFees\n        )\n    {\n        Pool.Slot0 memory slot0 = pools[id].slot0;\n\n        return (\n            slot0.sqrtPriceX96,\n            slot0.tick,\n            slot0.protocolFees,\n            slot0.hookFees\n        );\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLiquidity(\n        PoolId id\n    ) external view override returns (uint128 liquidity) {\n        return pools[id].liquidity;\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLiquidity(\n        PoolId id,\n        address _owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view override returns (uint128 liquidity) {\n        return pools[id].positions.get(_owner, tickLower, tickUpper).liquidity;\n    }\n\n    function getPosition(\n        PoolId id,\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) external view override returns (Position.Info memory position) {\n        return pools[id].positions.get(owner, tickLower, tickUpper);\n    }\n\n    /// @inheritdoc IPoolManager\n    function getLock(\n        uint256 i\n    ) external view override returns (address locker) {\n        return LockDataLibrary.getLock(i);\n    }\n\n    /// @inheritdoc IPoolManager\n    function initialize(\n        PoolKey memory key,\n        uint160 sqrtPriceX96,\n        bytes calldata hookData\n    ) external override returns (int24 tick) {\n        if (key.fee.isStaticFeeTooLarge()) revert FeeTooLarge();\n\n        // see TickBitmap.sol for overflow conditions that can arise from tick spacing being too large\n        if (key.tickSpacing > MAX_TICK_SPACING) revert TickSpacingTooLarge();\n        if (key.tickSpacing < MIN_TICK_SPACING) revert TickSpacingTooSmall();\n        if (key.currency0 >= key.currency1)\n            revert CurrenciesInitializedOutOfOrder();\n        if (!key.hooks.isValidHookAddress(key.fee))\n            revert Hooks.HookAddressNotValid(address(key.hooks));\n\n        if (key.hooks.shouldCallBeforeInitialize()) {\n            if (\n                key.hooks.beforeInitialize(\n                    msg.sender,\n                    key,\n                    sqrtPriceX96,\n                    hookData\n                ) != IHooks.beforeInitialize.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        PoolId id = key.toId();\n\n        uint24 swapFee = key.fee.isDynamicFee()\n            ? _fetchDynamicSwapFee(key)\n            : key.fee.getStaticFee();\n\n        tick = pools[id].initialize(\n            sqrtPriceX96,\n            _fetchProtocolFees(key),\n            _fetchHookFees(key),\n            swapFee\n        );\n\n        if (key.hooks.shouldCallAfterInitialize()) {\n            if (\n                key.hooks.afterInitialize(\n                    msg.sender,\n                    key,\n                    sqrtPriceX96,\n                    tick,\n                    hookData\n                ) != IHooks.afterInitialize.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        // On intitalize we emit the key's fee, which tells us all fee settings a pool can have: either a static swap fee or dynamic swap fee and if the hook has enabled swap or withdraw fees.\n        emit Initialize(\n            id,\n            key.currency0,\n            key.currency1,\n            key.fee,\n            key.tickSpacing,\n            key.hooks\n        );\n    }\n\n    /// @inheritdoc IPoolManager\n    function lock(\n        bytes calldata data\n    ) external override returns (bytes memory result) {\n        lockData.push(msg.sender);\n\n        // the caller does everything in this callback, including paying what they owe via calls to settle\n        result = ILockCallback(msg.sender).lockAcquired(data);\n\n        if (lockData.length == 1) {\n            if (lockData.nonzeroDeltaCount != 0) revert CurrencyNotSettled();\n            delete lockData;\n        } else {\n            lockData.pop();\n        }\n    }\n\n    function _accountDelta(Currency currency, int128 delta) internal {\n        if (delta == 0) return;\n\n        address locker = lockData.getActiveLock();\n        int256 current = currencyDelta[locker][currency];\n        int256 next = current + delta;\n\n        unchecked {\n            if (next == 0) {\n                lockData.nonzeroDeltaCount--;\n            } else if (current == 0) {\n                lockData.nonzeroDeltaCount++;\n            }\n        }\n\n        currencyDelta[locker][currency] = next;\n    }\n\n    /// @dev Accumulates a balance change to a map of currency to balance changes\n    function _accountPoolBalanceDelta(\n        PoolKey memory key,\n        BalanceDelta delta\n    ) internal {\n        _accountDelta(key.currency0, delta.amount0());\n        _accountDelta(key.currency1, delta.amount1());\n    }\n\n    modifier onlyByLocker() {\n        address locker = lockData.getActiveLock();\n        if (msg.sender != locker) revert LockedBy(locker);\n        _;\n    }\n\n    /// @inheritdoc IPoolManager\n    function modifyPosition(\n        PoolKey memory key,\n        IPoolManager.ModifyPositionParams memory params,\n        bytes calldata hookData\n    )\n        external\n        override\n        noDelegateCall\n        onlyByLocker\n        returns (BalanceDelta delta)\n    {\n        if (key.hooks.shouldCallBeforeModifyPosition()) {\n            if (\n                key.hooks.beforeModifyPosition(\n                    msg.sender,\n                    key,\n                    params,\n                    hookData\n                ) != IHooks.beforeModifyPosition.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        PoolId id = key.toId();\n        Pool.FeeAmounts memory feeAmounts;\n\n        (delta, feeAmounts) = pools[id].modifyPosition(\n            Pool.ModifyPositionParams({\n                owner: msg.sender,\n                tickLower: params.tickLower,\n                tickUpper: params.tickUpper,\n                liquidityDelta: params.liquidityDelta.toInt128(),\n                tickSpacing: key.tickSpacing\n            })\n        );\n        _accountPoolBalanceDelta(key, delta);\n\n        unchecked {\n            if (feeAmounts.feeForProtocol0 > 0) {\n                protocolFeesAccrued[key.currency0] += feeAmounts\n                    .feeForProtocol0;\n            }\n            if (feeAmounts.feeForProtocol1 > 0) {\n                protocolFeesAccrued[key.currency1] += feeAmounts\n                    .feeForProtocol1;\n            }\n            if (feeAmounts.feeForHook0 > 0) {\n                hookFeesAccrued[address(key.hooks)][key.currency0] += feeAmounts\n                    .feeForHook0;\n            }\n            if (feeAmounts.feeForHook1 > 0) {\n                hookFeesAccrued[address(key.hooks)][key.currency1] += feeAmounts\n                    .feeForHook1;\n            }\n        }\n\n        if (key.hooks.shouldCallAfterModifyPosition()) {\n            if (\n                key.hooks.afterModifyPosition(\n                    msg.sender,\n                    key,\n                    params,\n                    delta,\n                    hookData\n                ) != IHooks.afterModifyPosition.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        emit ModifyPosition(\n            id,\n            msg.sender,\n            params.tickLower,\n            params.tickUpper,\n            params.liquidityDelta\n        );\n    }\n\n    /// @inheritdoc IPoolManager\n    function swap(\n        PoolKey memory key,\n        IPoolManager.SwapParams memory params,\n        bytes calldata hookData\n    )\n        external\n        override\n        noDelegateCall\n        onlyByLocker\n        returns (BalanceDelta delta)\n    {\n        if (key.hooks.shouldCallBeforeSwap()) {\n            if (\n                key.hooks.beforeSwap(msg.sender, key, params, hookData) !=\n                IHooks.beforeSwap.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        PoolId id = key.toId();\n\n        uint256 feeForProtocol;\n        uint256 feeForHook;\n        uint24 swapFee;\n        Pool.SwapState memory state;\n        (delta, feeForProtocol, feeForHook, swapFee, state) = pools[id].swap(\n            Pool.SwapParams({\n                tickSpacing: key.tickSpacing,\n                zeroForOne: params.zeroForOne,\n                amountSpecified: params.amountSpecified,\n                sqrtPriceLimitX96: params.sqrtPriceLimitX96\n            })\n        );\n\n        _accountPoolBalanceDelta(key, delta);\n        // the fee is on the input currency\n\n        unchecked {\n            if (feeForProtocol > 0) {\n                protocolFeesAccrued[\n                    params.zeroForOne ? key.currency0 : key.currency1\n                ] += feeForProtocol;\n            }\n            if (feeForHook > 0) {\n                hookFeesAccrued[address(key.hooks)][\n                    params.zeroForOne ? key.currency0 : key.currency1\n                ] += feeForHook;\n            }\n        }\n\n        if (key.hooks.shouldCallAfterSwap()) {\n            if (\n                key.hooks.afterSwap(msg.sender, key, params, delta, hookData) !=\n                IHooks.afterSwap.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        emit Swap(\n            id,\n            msg.sender,\n            delta.amount0(),\n            delta.amount1(),\n            state.sqrtPriceX96,\n            state.liquidity,\n            state.tick,\n            swapFee\n        );\n    }\n\n    /// @inheritdoc IPoolManager\n    function donate(\n        PoolKey memory key,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata hookData\n    )\n        external\n        override\n        noDelegateCall\n        onlyByLocker\n        returns (BalanceDelta delta)\n    {\n        if (key.hooks.shouldCallBeforeDonate()) {\n            if (\n                key.hooks.beforeDonate(\n                    msg.sender,\n                    key,\n                    amount0,\n                    amount1,\n                    hookData\n                ) != IHooks.beforeDonate.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n\n        delta = _getPool(key).donate(amount0, amount1);\n\n        _accountPoolBalanceDelta(key, delta);\n\n        if (key.hooks.shouldCallAfterDonate()) {\n            if (\n                key.hooks.afterDonate(\n                    msg.sender,\n                    key,\n                    amount0,\n                    amount1,\n                    hookData\n                ) != IHooks.afterDonate.selector\n            ) {\n                revert Hooks.InvalidHookResponse();\n            }\n        }\n    }\n\n    /// @inheritdoc IPoolManager\n    function take(\n        Currency currency,\n        address to,\n        uint256 amount\n    ) external override noDelegateCall onlyByLocker {\n        _accountDelta(currency, amount.toInt128());\n        reservesOf[currency] -= amount;\n        currency.transfer(to, amount);\n    }\n\n    /// @inheritdoc IPoolManager\n    function settle(\n        Currency currency\n    )\n        external\n        payable\n        override\n        noDelegateCall\n        onlyByLocker\n        returns (uint256 paid)\n    {\n        uint256 reservesBefore = reservesOf[currency];\n        reservesOf[currency] = currency.balanceOfSelf();\n        paid = reservesOf[currency] - reservesBefore;\n        // subtraction must be safe\n        _accountDelta(currency, -(paid.toInt128()));\n    }\n\n    /// @inheritdoc IPoolManager\n    function mint(\n        Currency currency,\n        address to,\n        uint256 amount\n    ) external noDelegateCall onlyByLocker {\n        _accountDelta(currency, amount.toInt128());\n        _mint(to, currency, amount);\n    }\n\n    /// @inheritdoc IPoolManager\n    function burn(\n        Currency currency,\n        uint256 amount\n    ) external noDelegateCall onlyByLocker {\n        _accountDelta(currency, -(amount.toInt128()));\n        _burn(currency, amount);\n    }\n\n    function setProtocolFees(PoolKey memory key) external {\n        uint24 newProtocolFees = _fetchProtocolFees(key);\n        PoolId id = key.toId();\n        pools[id].setProtocolFees(newProtocolFees);\n        emit ProtocolFeeUpdated(id, newProtocolFees);\n    }\n\n    function setHookFees(PoolKey memory key) external {\n        uint24 newHookFees = _fetchHookFees(key);\n        PoolId id = key.toId();\n        pools[id].setHookFees(newHookFees);\n        emit HookFeeUpdated(id, newHookFees);\n    }\n\n    function updateDynamicSwapFee(PoolKey memory key) external {\n        if (key.fee.isDynamicFee()) {\n            uint24 newDynamicSwapFee = _fetchDynamicSwapFee(key);\n            PoolId id = key.toId();\n            pools[id].setSwapFee(newDynamicSwapFee);\n            emit DynamicSwapFeeUpdated(id, newDynamicSwapFee);\n        } else {\n            revert FeeNotDynamic();\n        }\n    }\n\n    function extsload(bytes32 slot) external view returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := sload(slot)\n        }\n    }\n\n    function extsload(\n        bytes32 startSlot,\n        uint256 nSlots\n    ) external view returns (bytes memory) {\n        bytes memory value = new bytes(32 * nSlots);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {\n                let i := 0\n            } lt(i, nSlots) {\n                i := add(i, 1)\n            } {\n                mstore(add(value, mul(add(i, 1), 32)), sload(add(startSlot, i)))\n            }\n        }\n\n        return value;\n    }\n\n    /// @notice receive native tokens for native pools\n    receive() external payable {}\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/BalanceDelta.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ntype BalanceDelta is int256;\n\nusing {add as +, sub as -} for BalanceDelta global;\nusing BalanceDeltaLibrary for BalanceDelta global;\n\nfunction toBalanceDelta(int128 _amount0, int128 _amount1) pure returns (BalanceDelta balanceDelta) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        balanceDelta :=\n            or(shl(128, _amount0), and(0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff, _amount1))\n    }\n}\n\nfunction add(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() + b.amount0(), a.amount1() + b.amount1());\n}\n\nfunction sub(BalanceDelta a, BalanceDelta b) pure returns (BalanceDelta) {\n    return toBalanceDelta(a.amount0() - b.amount0(), a.amount1() - b.amount1());\n}\n\nlibrary BalanceDeltaLibrary {\n    function amount0(BalanceDelta balanceDelta) internal pure returns (int128 _amount0) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount0 := shr(128, balanceDelta)\n        }\n    }\n\n    function amount1(BalanceDelta balanceDelta) internal pure returns (int128 _amount1) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            _amount1 := balanceDelta\n        }\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/Currency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {IERC20Minimal} from \"../interfaces/external/IERC20Minimal.sol\";\n\ntype Currency is address;\n\nusing {greaterThan as >, lessThan as <, greaterThanOrEqualTo as >=, equals as ==} for Currency global;\n\nfunction equals(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) == Currency.unwrap(other);\n}\n\nfunction greaterThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) > Currency.unwrap(other);\n}\n\nfunction lessThan(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) < Currency.unwrap(other);\n}\n\nfunction greaterThanOrEqualTo(Currency currency, Currency other) pure returns (bool) {\n    return Currency.unwrap(currency) >= Currency.unwrap(other);\n}\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring and holding native tokens and ERC20 tokens\nlibrary CurrencyLibrary {\n    using CurrencyLibrary for Currency;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Thrown when an ERC20 transfer fails\n    error ERC20TransferFailed();\n\n    Currency public constant NATIVE = Currency.wrap(address(0));\n\n    function transfer(Currency currency, address to, uint256 amount) internal {\n        // implementation from\n        // https://github.com/transmissions11/solmate/blob/e8f96f25d48fe702117ce76c79228ca4f20206cb/src/utils/SafeTransferLib.sol\n\n        bool success;\n        if (currency.isNative()) {\n            assembly {\n                // Transfer the ETH and store if it succeeded or not.\n                success := call(gas(), to, amount, 0, 0, 0, 0)\n            }\n\n            if (!success) revert NativeTransferFailed();\n        } else {\n            assembly {\n                // We'll write our calldata to this slot below, but restore it later.\n                let memPointer := mload(0x40)\n\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\n                mstore(0, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n                mstore(4, to) // Append the \"to\" argument.\n                mstore(36, amount) // Append the \"amount\" argument.\n\n                success :=\n                    and(\n                        // Set success to whether the call reverted, if not we check it either\n                        // returned exactly 1 (can't just be non-zero data), or had no return data.\n                        or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                        // We use 68 because that's the total length of our calldata (4 + 32 * 2)\n                        // Counterintuitively, this call() must be positioned after the or() in the\n                        // surrounding and() because and() evaluates its arguments from right to left.\n                        call(gas(), currency, 0, 0, 68, 0, 32)\n                    )\n\n                mstore(0x60, 0) // Restore the zero slot to zero.\n                mstore(0x40, memPointer) // Restore the memPointer.\n            }\n\n            if (!success) revert ERC20TransferFailed();\n        }\n    }\n\n    function balanceOfSelf(Currency currency) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return address(this).balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(address(this));\n        }\n    }\n\n    function balanceOf(Currency currency, address owner) internal view returns (uint256) {\n        if (currency.isNative()) {\n            return owner.balance;\n        } else {\n            return IERC20Minimal(Currency.unwrap(currency)).balanceOf(owner);\n        }\n    }\n\n    function isNative(Currency currency) internal pure returns (bool) {\n        return Currency.unwrap(currency) == Currency.unwrap(NATIVE);\n    }\n\n    function toId(Currency currency) internal pure returns (uint256) {\n        return uint160(Currency.unwrap(currency));\n    }\n\n    function fromId(uint256 id) internal pure returns (Currency) {\n        return Currency.wrap(address(uint160(id)));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/PoolId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {PoolKey} from \"./PoolKey.sol\";\n\ntype PoolId is bytes32;\n\n/// @notice Library for computing the ID of a pool\nlibrary PoolIdLibrary {\n    function toId(PoolKey memory poolKey) internal pure returns (PoolId) {\n        return PoolId.wrap(keccak256(abi.encode(poolKey)));\n    }\n}\n"
    },
    "contracts/Uniswap/V4-Core/types/PoolKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Currency} from \"./Currency.sol\";\nimport {IHooks} from \"../interfaces/IHooks.sol\";\n\n/// @notice Returns the key for identifying a pool\nstruct PoolKey {\n    /// @notice The lower currency of the pool, sorted numerically\n    Currency currency0;\n    /// @notice The higher currency of the pool, sorted numerically\n    Currency currency1;\n    /// @notice The pool swap fee, capped at 1_000_000. The upper 4 bits determine if the hook sets any fees.\n    uint24 fee;\n    /// @notice Ticks that involve positions must be a multiple of tick spacing\n    int24 tickSpacing;\n    /// @notice The hooks of the pool\n    IHooks hooks;\n}\n"
    },
    "contracts/UniswapV3LiquidityProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IUniswapV3Factory.sol\";\nimport \"./IUniswapV3Pool.sol\";\nimport \"./ILiquidityProvider.sol\";\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\n\ncontract UniswapV3LiquidityProvider is ILiquidityProvider, IDataProvider {\n\tIUniswapV3Factory public factory;\n\tuint24[] public feeTiers = [500, 3000, 10000]; // Example fee tiers: 0.05%, 0.3%, 1% these are Uniswap V3 standards\n\taddress[] public comparisonTokens;\n\tuint256 public mockPrice = 1000;\n\taddress public token;\n\tuint32 public chainId;\n\n\tconstructor(\n\t\taddress _factory,\n\t\taddress[] memory _comparisonTokens,\n\t\taddress _token,\n\t\tuint32 _chainId\n\t) {\n\t\tfactory = IUniswapV3Factory(_factory);\n\t\tcomparisonTokens = _comparisonTokens;\n\t\ttoken = _token;\n\t\tchainId = _chainId;\n\t}\n\n\tfunction getPoolsForToken(\n\t\taddress token\n\t) public view returns (address[] memory) {\n\t\tuint256 poolCount = 0;\n\t\taddress[] memory tempPools = new address[](\n\t\t\tcomparisonTokens.length * feeTiers.length\n\t\t);\n\n\t\tfor (uint256 i = 0; i < comparisonTokens.length; i++) {\n\t\t\tif (comparisonTokens[i] == token) continue;\n\t\t\tfor (uint256 j = 0; j < feeTiers.length; j++) {\n\t\t\t\taddress pool = factory.getPool(\n\t\t\t\t\ttoken,\n\t\t\t\t\tcomparisonTokens[i],\n\t\t\t\t\tfeeTiers[j]\n\t\t\t\t);\n\t\t\t\tif (pool != address(0)) {\n\t\t\t\t\ttempPools[poolCount] = pool;\n\t\t\t\t\tpoolCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create an array of the actual size\n\t\taddress[] memory pools = new address[](poolCount);\n\t\tfor (uint256 i = 0; i < poolCount; i++) {\n\t\t\tpools[i] = tempPools[i];\n\t\t}\n\n\t\treturn pools;\n\t}\n\n\tfunction getTokenLiquidity(\n\t\taddress token\n\t) public view returns (uint256 totalLiquidity) {\n\t\taddress[] memory pools = getPoolsForToken(token);\n\t\tfor (uint256 i = 0; i < pools.length; i++) {\n\t\t\ttotalLiquidity += 1;\n\t\t\tIUniswapV3Pool(pools[i]).liquidity();\n\t\t}\n\t}\n\n\tfunction getPrice(\n\t\taddress token\n\t) public view returns (uint256 averagePrice) {\n\t\tuint256 sumPrice = 0;\n\t\tuint256 count = 0;\n\t\taddress[] memory pools = getPoolsForToken(token);\n\n\t\tfor (uint256 i = 0; i < pools.length; i++) {\n\t\t\tsumPrice += mockPrice;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\taveragePrice = sumPrice / count;\n\t\t}\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn\n\t\t\tstring(\n\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\"UniswapV3LiquidityProvider\",\n\t\t\t\t\tIERC20(token).name()\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\tfunction getMetricData(\n\t) external view override returns (uint256) {\n\t\treturn getTokenLiquidity(token);\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\t// return \"onchain\", \"uniswap\", \"liquidity\";\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"onchain\";\n\t\ttags[1] = \"uniswap\";\n\t\ttags[2] = \"liquidity\";\n\t\ttags[3] = IERC20(token).name();\n\t\treturn tags;\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.LIQUIDITY;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\n\tfunction getChainId() external view override returns (uint32) {\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/UniswapV3PriceProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IUniswapV3Factory.sol\";\nimport \"./IUniswapV3Pool.sol\";\nimport \"./IDataProvider.sol\";\nimport { IERC20 } from \"./IERC20.sol\";\n\ncontract UniswapV3PriceProvider is IDataProvider {\n\tIUniswapV3Factory public factory;\n\tuint24[] public feeTiers = [500, 3000, 10000]; // Example fee tiers: 0.05%, 0.3%, 1% these are Uniswap V3 standards\n\taddress[] public comparisonTokens;\n\tuint256 public mockPrice = 1000;\n\taddress public token;\n\tuint32 public chainId;\n\n\tconstructor(\n\t\taddress _factory,\n\t\taddress[] memory _comparisonTokens,\n\t\taddress _token,\n\t\tuint32 _chainId\n\t) {\n\t\tfactory = IUniswapV3Factory(_factory);\n\t\tcomparisonTokens = _comparisonTokens;\n\t\ttoken = _token;\n\t\tchainId = _chainId;\n\t}\n\n\tfunction getPoolsForToken(\n\t\taddress token\n\t) public view returns (address[] memory) {\n\t\tuint256 poolCount = 0;\n\t\taddress[] memory tempPools = new address[](\n\t\t\tcomparisonTokens.length * feeTiers.length\n\t\t);\n\n\t\tfor (uint256 i = 0; i < comparisonTokens.length; i++) {\n\t\t\tif (comparisonTokens[i] == token) continue;\n\t\t\tfor (uint256 j = 0; j < feeTiers.length; j++) {\n\t\t\t\taddress pool = factory.getPool(\n\t\t\t\t\ttoken,\n\t\t\t\t\tcomparisonTokens[i],\n\t\t\t\t\tfeeTiers[j]\n\t\t\t\t);\n\t\t\t\tif (pool != address(0)) {\n\t\t\t\t\ttempPools[poolCount] = pool;\n\t\t\t\t\tpoolCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Create an array of the actual size\n\t\taddress[] memory pools = new address[](poolCount);\n\t\tfor (uint256 i = 0; i < poolCount; i++) {\n\t\t\tpools[i] = tempPools[i];\n\t\t}\n\n\t\treturn pools;\n\t}\n\n\tfunction getPrice(\n\t\taddress token\n\t) public view returns (uint256 averagePrice) {\n\t\tuint256 sumPrice = 0;\n\t\tuint256 count = 0;\n\t\taddress[] memory pools = getPoolsForToken(token);\n\n\t\tfor (uint256 i = 0; i < pools.length; i++) {\n\t\t\tsumPrice += mockPrice;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (count > 0) {\n\t\t\taveragePrice = sumPrice / count;\n\t\t}\n\t}\n\n\tfunction getLabel() external view override returns (string memory) {\n\t\treturn\n\t\t\tstring(\n\t\t\t\tabi.encodePacked(\"UniswapV3PriceProvider\", IERC20(token).name())\n\t\t\t);\n\t}\n\n\tfunction getMetricData(\n\t) external view override returns (uint256) {\n\t\treturn getPrice(token);\n\t}\n\n\tfunction getDataTimestamp() external view override returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n\n\tfunction getTags() external view override returns (string[] memory) {\n\t\tstring[] memory tags = new string[](4);\n\t\ttags[0] = \"onchain\";\n\t\ttags[1] = \"uniswap\";\n\t\ttags[2] = \"price\";\n\t\ttags[3] = IERC20(token).name();\n\t\treturn tags;\n\t}\n\n\tfunction getDataType() external pure returns (DataTypes) {\n\t\treturn DataTypes.PRICE;\n\t}\n\n\tfunction getAssetAddress() external view override returns (address) {\n\t\treturn token;\n\t}\n\n\tfunction getChainId() external view override returns (uint32) {\n\t\treturn chainId;\n\t}\n}\n"
    },
    "contracts/YourContract.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n// Useful for debugging. Remove when deploying to a live network.\nimport \"hardhat/console.sol\";\n\n// Use openzeppelin to inherit battle-tested implementations (ERC20, ERC721, etc)\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * A smart contract that allows changing a state variable of the contract and tracking the changes\n * It also allows the owner to withdraw the Ether in the contract\n * @author BuidlGuidl\n */\ncontract YourContract {\n\t// State Variables\n\taddress public immutable owner;\n\tstring public greeting = \"Building Unstoppable Apps!!!\";\n\tbool public premium = false;\n\tuint256 public totalCounter = 0;\n\tmapping(address => uint) public userGreetingCounter;\n\n\t// Events: a way to emit log statements from smart contract that can be listened to by external parties\n\tevent GreetingChange(\n\t\taddress indexed greetingSetter,\n\t\tstring newGreeting,\n\t\tbool premium,\n\t\tuint256 value\n\t);\n\n\t// Constructor: Called once on contract deployment\n\t// Check packages/hardhat/deploy/00_deploy_your_contract.ts\n\tconstructor(address _owner) {\n\t\towner = _owner;\n\t}\n\n\t// Modifier: used to define a set of rules that must be met before or after a function is executed\n\t// Check the withdraw() function\n\tmodifier isOwner() {\n\t\t// msg.sender: predefined variable that represents address of the account that called the current function\n\t\trequire(msg.sender == owner, \"Not the Owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * Function that allows anyone to change the state variable \"greeting\" of the contract and increase the counters\n\t *\n\t * @param _newGreeting (string memory) - new greeting to save on the contract\n\t */\n\tfunction setGreeting(string memory _newGreeting) public payable {\n\t\t// Print data to the hardhat chain console. Remove when deploying to a live network.\n\t\tconsole.log(\n\t\t\t\"Setting new greeting '%s' from %s\",\n\t\t\t_newGreeting,\n\t\t\tmsg.sender\n\t\t);\n\n\t\t// Change state variables\n\t\tgreeting = _newGreeting;\n\t\ttotalCounter += 1;\n\t\tuserGreetingCounter[msg.sender] += 1;\n\n\t\t// msg.value: built-in global variable that represents the amount of ether sent with the transaction\n\t\tif (msg.value > 0) {\n\t\t\tpremium = true;\n\t\t} else {\n\t\t\tpremium = false;\n\t\t}\n\n\t\t// emit: keyword used to trigger an event\n\t\temit GreetingChange(msg.sender, _newGreeting, msg.value > 0, msg.value);\n\t}\n\n\t/**\n\t * Function that allows the owner to withdraw all the Ether in the contract\n\t * The function can only be called by the owner of the contract as defined by the isOwner modifier\n\t */\n\tfunction withdraw() public isOwner {\n\t\t(bool success, ) = owner.call{ value: address(this).balance }(\"\");\n\t\trequire(success, \"Failed to send Ether\");\n\t}\n\n\t/**\n\t * Function that allows the contract to receive ETH\n\t */\n\treceive() external payable {}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}