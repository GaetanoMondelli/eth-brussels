{
  "language": "Solidity",
  "sources": {
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IBn256.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n// G1Point implements a point in G1 group.\nstruct G1Point {\n  uint256 x;\n  uint256 y;\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n\nimport { SortitionCredential } from \"./ISortition.sol\";\n\n/**\n * Fast updater interface.\n */\ninterface IFastUpdater {\n\n    /// Signature structure\n    struct Signature {\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /// Fast update structure\n    struct FastUpdates {\n        uint256 sortitionBlock;\n        SortitionCredential sortitionCredential;\n        bytes deltas;\n        Signature signature;\n    }\n\n    /// Event emitted when a new set of updates is submitted.\n    event FastUpdateFeedsSubmitted(\n        uint32 indexed votingRoundId,\n        address indexed signingPolicyAddress\n    );\n\n    /// Event emitted when a feed is added or reset.\n    event FastUpdateFeedReset(\n        uint256 indexed votingRoundId,\n        uint256 indexed index,\n        bytes21 indexed id,\n        uint256 value,\n        int8 decimals);\n\n    /// Event emitted when a feed is removed.\n    event FastUpdateFeedRemoved(\n        uint256 indexed index);\n\n    /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.\n    event FastUpdateFeeds(uint256 indexed votingEpochId, uint256[] feeds, int8[] decimals);\n\n    /**\n     * The entry point for providers to submit an update transaction.\n     * @param _updates Data of an update transaction, which in addition to the actual list of updates,\n     * includes the sortition credential proving the provider's eligibility to make updates in the also-included\n     * sortition round, as well as a signature allowing a single registered provider to submit from multiple\n     * EVM accounts.\n     */\n    function submitUpdates(FastUpdates calldata _updates) external;\n\n    /**\n     * Public access to the stored data of all feeds.\n     * @return _feedIds The list of feed ids.\n     * @return _feeds The list of feeds.\n     * @return _decimals The list of decimal places for feeds.\n     * @return _timestamp The timestamp of the last update.\n     */\n    function fetchAllCurrentFeeds()\n        external view\n        returns (\n            bytes21[] memory _feedIds,\n            uint256[] memory _feeds,\n            int8[] memory _decimals,\n            uint64 _timestamp\n        );\n\n    /**\n     * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.\n     * Feeds should be sorted for better performance.\n     * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in\n     * the `FastUpdatesConfiguration` contract.\n     * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given\n     * (which may not be their sorted order).\n     * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were\n     * given (which may not be their sorted order).\n     * @return _timestamp The timestamp of the last update.\n     */\n    function fetchCurrentFeeds(\n        uint256[] calldata _indices\n    )\n        external view\n        returns (\n            uint256[] memory _feeds,\n            int8[] memory _decimals,\n            uint64 _timestamp\n        );\n\n    /**\n     * Informational getter concerning the eligibility criterion for being chosen by sortition.\n     * @return _cutoff The upper endpoint of the acceptable range of \"scores\" that providers generate for sortition.\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\n     */\n    function currentScoreCutoff() external view returns (uint256 _cutoff);\n\n    /**\n     * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.\n     * @param _blockNum The block for which the cutoff is requested.\n     * @return _cutoff The upper endpoint of the acceptable range of \"scores\" that providers generate for sortition.\n     * A score below the cutoff indicates eligibility to submit updates in the present sortition round.\n     */\n    function blockScoreCutoff(uint256 _blockNum) external view returns (uint256 _cutoff);\n\n    /**\n     * Informational getter concerning a provider's likelihood of being chosen by sortition.\n     * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the\n     * sender of an update transaction, due to the signature included in the `FastUpdates` type.\n     * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's\n     * delegation weight for the FTSO, but rescaled against a fixed number of \"virtual providers\", indicating how many\n     * potential updates a single provider may make in a sortition round.\n     */\n    function currentSortitionWeight(address _signingPolicyAddress) external view returns (uint256 _weight);\n\n    /**\n     * The submission window is a number of blocks forming a \"grace period\" after a round of sortition starts,\n     * during which providers may submit updates for that round. In other words, each block starts a new round of\n     * sortition and that round lasts `submissionWindow` blocks.\n     */\n    function submissionWindow() external view returns (uint8);\n\n    /**\n     * Id of the current reward epoch.\n     */\n    function currentRewardEpochId() external view returns (uint24);\n\n    /**\n     * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).\n     * @param _historySize The number of blocks for which the number of updates should be returned.\n     * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.\n     * The array is ordered from the current block to the oldest block.\n     */\n    function numberOfUpdates(uint256 _historySize) external view returns (uint256[] memory _noOfUpdates);\n\n    /**\n     * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.\n     * @param _blockNumber The block number for which the number of updates should be returned.\n     * @return _noOfUpdates The number of updates submitted in the specified block.\n     */\n    function numberOfUpdatesInBlock(uint256 _blockNumber) external view returns (uint256 _noOfUpdates);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/ISortition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {G1Point} from \"./IBn256.sol\";\n\nstruct SortitionCredential {\n  uint256 replicate;\n  G1Point gamma;\n  uint256 c;\n  uint256 s;\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\ninterface IFlareContractRegistry {\n    /**\n     * @notice Returns contract address for the given name - might be address(0)\n     * @param _name             name of the contract\n     */\n    function getContractAddressByName(string calldata _name) external view returns(address);\n\n    /**\n     * @notice Returns contract address for the given name hash - might be address(0)\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\n     */\n    function getContractAddressByHash(bytes32 _nameHash) external view returns(address);\n\n    /**\n     * @notice Returns contract addresses for the given names - might be address(0)\n     * @param _names            names of the contracts\n     */\n    function getContractAddressesByName(string[] calldata _names) external view returns(address[] memory);\n\n    /**\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\n     */\n    function getContractAddressesByHash(bytes32[] calldata _nameHashes) external view returns(address[] memory);\n\n    /**\n     * @notice Returns all contract names and corresponding addresses\n     */\n    function getAllContracts() external view returns(string[] memory _names, address[] memory _addresses);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { ILayerZeroEndpointV2 } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\n/**\n * @title IOAppCore\n */\ninterface IOAppCore {\n    // Custom error messages\n    error OnlyPeer(uint32 eid, bytes32 sender);\n    error NoPeer(uint32 eid);\n    error InvalidEndpointCall();\n    error InvalidDelegate();\n\n    // Event emitted when a peer (OApp) is set for a corresponding endpoint\n    event PeerSet(uint32 eid, bytes32 peer);\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     */\n    function oAppVersion() external view returns (uint64 senderVersion, uint64 receiverVersion);\n\n    /**\n     * @notice Retrieves the LayerZero endpoint associated with the OApp.\n     * @return iEndpoint The LayerZero endpoint as an interface.\n     */\n    function endpoint() external view returns (ILayerZeroEndpointV2 iEndpoint);\n\n    /**\n     * @notice Retrieves the peer (OApp) associated with a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @return peer The peer address (OApp instance) associated with the corresponding endpoint.\n     */\n    function peers(uint32 _eid) external view returns (bytes32 peer);\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) external;\n\n    /**\n     * @notice Sets the delegate address for the OApp Core.\n     * @param _delegate The address of the delegate to be set.\n     */\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/interfaces/IOAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ILayerZeroReceiver, Origin } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol\";\n\ninterface IOAppReceiver is ILayerZeroReceiver {\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement a separate composeMsg sender that is NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata _origin,\n        bytes calldata _message,\n        address _sender\n    ) external view returns (bool isSender);\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\n// @dev Import the 'MessagingFee' and 'MessagingReceipt' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppSender, MessagingFee, MessagingReceipt } from \"./OAppSender.sol\";\n// @dev Import the 'Origin' so it's exposed to OApp implementers\n// solhint-disable-next-line no-unused-import\nimport { OAppReceiver, Origin } from \"./OAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OApp\n * @dev Abstract contract serving as the base for OApp implementation, combining OAppSender and OAppReceiver functionality.\n */\nabstract contract OApp is OAppSender, OAppReceiver {\n    /**\n     * @dev Constructor to initialize the OApp with the provided endpoint and owner.\n     * @param _endpoint The address of the LOCAL LayerZero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     */\n    constructor(address _endpoint, address _delegate) OAppCore(_endpoint, _delegate) {}\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol implementation.\n     * @return receiverVersion The version of the OAppReceiver.sol implementation.\n     */\n    function oAppVersion()\n        public\n        pure\n        virtual\n        override(OAppSender, OAppReceiver)\n        returns (uint64 senderVersion, uint64 receiverVersion)\n    {\n        return (SENDER_VERSION, RECEIVER_VERSION);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { IOAppCore, ILayerZeroEndpointV2 } from \"./interfaces/IOAppCore.sol\";\n\n/**\n * @title OAppCore\n * @dev Abstract contract implementing the IOAppCore interface with basic OApp configurations.\n */\nabstract contract OAppCore is IOAppCore, Ownable {\n    // The LayerZero endpoint associated with the given OApp\n    ILayerZeroEndpointV2 public immutable endpoint;\n\n    // Mapping to store peers associated with corresponding endpoints\n    mapping(uint32 eid => bytes32 peer) public peers;\n\n    /**\n     * @dev Constructor to initialize the OAppCore with the provided endpoint and delegate.\n     * @param _endpoint The address of the LOCAL Layer Zero endpoint.\n     * @param _delegate The delegate capable of making OApp configurations inside of the endpoint.\n     *\n     * @dev The delegate typically should be set as the owner of the contract.\n     */\n    constructor(address _endpoint, address _delegate) {\n        endpoint = ILayerZeroEndpointV2(_endpoint);\n\n        if (_delegate == address(0)) revert InvalidDelegate();\n        endpoint.setDelegate(_delegate);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function setPeer(uint32 _eid, bytes32 _peer) public virtual onlyOwner {\n        _setPeer(_eid, _peer);\n    }\n\n    /**\n     * @notice Sets the peer address (OApp instance) for a corresponding endpoint.\n     * @param _eid The endpoint ID.\n     * @param _peer The address of the peer to be associated with the corresponding endpoint.\n     *\n     * @dev Indicates that the peer is trusted to send LayerZero messages to this OApp.\n     * @dev Set this to bytes32(0) to remove the peer address.\n     * @dev Peer is a bytes32 to accommodate non-evm chains.\n     */\n    function _setPeer(uint32 _eid, bytes32 _peer) internal virtual {\n        peers[_eid] = _peer;\n        emit PeerSet(_eid, _peer);\n    }\n\n    /**\n     * @notice Internal function to get the peer address associated with a specific endpoint; reverts if NOT set.\n     * ie. the peer is set to bytes32(0).\n     * @param _eid The endpoint ID.\n     * @return peer The address of the peer associated with the specified endpoint.\n     */\n    function _getPeerOrRevert(uint32 _eid) internal view virtual returns (bytes32) {\n        bytes32 peer = peers[_eid];\n        if (peer == bytes32(0)) revert NoPeer(_eid);\n        return peer;\n    }\n\n    /**\n     * @notice Sets the delegate address for the OApp.\n     * @param _delegate The address of the delegate to be set.\n     *\n     * @dev Only the owner/admin of the OApp can call this function.\n     * @dev Provides the ability for a delegate to set configs, on behalf of the OApp, directly on the Endpoint contract.\n     */\n    function setDelegate(address _delegate) public onlyOwner {\n        endpoint.setDelegate(_delegate);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { IOAppReceiver, Origin } from \"./interfaces/IOAppReceiver.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppReceiver\n * @dev Abstract contract implementing the ILayerZeroReceiver interface and extending OAppCore for OApp receivers.\n */\nabstract contract OAppReceiver is IOAppReceiver, OAppCore {\n    // Custom error message for when the caller is not the registered endpoint/\n    error OnlyEndpoint(address addr);\n\n    // @dev The version of the OAppReceiver implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant RECEIVER_VERSION = 2;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppSender version. Indicates that the OAppSender is not implemented.\n     * ie. this is a RECEIVE only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions.\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (0, RECEIVER_VERSION);\n    }\n\n    /**\n     * @notice Indicates whether an address is an approved composeMsg sender to the Endpoint.\n     * @dev _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @dev _message The lzReceive payload.\n     * @param _sender The sender address.\n     * @return isSender Is a valid sender.\n     *\n     * @dev Applications can optionally choose to implement separate composeMsg senders that are NOT the bridging layer.\n     * @dev The default sender IS the OAppReceiver implementer.\n     */\n    function isComposeMsgSender(\n        Origin calldata /*_origin*/,\n        bytes calldata /*_message*/,\n        address _sender\n    ) public view virtual returns (bool) {\n        return _sender == address(this);\n    }\n\n    /**\n     * @notice Checks if the path initialization is allowed based on the provided origin.\n     * @param origin The origin information containing the source endpoint and sender address.\n     * @return Whether the path has been initialized.\n     *\n     * @dev This indicates to the endpoint that the OApp has enabled msgs for this particular path to be received.\n     * @dev This defaults to assuming if a peer has been set, its initialized.\n     * Can be overridden by the OApp if there is other logic to determine this.\n     */\n    function allowInitializePath(Origin calldata origin) public view virtual returns (bool) {\n        return peers[origin.srcEid] == origin.sender;\n    }\n\n    /**\n     * @notice Retrieves the next nonce for a given source endpoint and sender address.\n     * @dev _srcEid The source endpoint ID.\n     * @dev _sender The sender address.\n     * @return nonce The next nonce.\n     *\n     * @dev The path nonce starts from 1. If 0 is returned it means that there is NO nonce ordered enforcement.\n     * @dev Is required by the off-chain executor to determine the OApp expects msg execution is ordered.\n     * @dev This is also enforced by the OApp.\n     * @dev By default this is NOT enabled. ie. nextNonce is hardcoded to return 0.\n     */\n    function nextNonce(uint32 /*_srcEid*/, bytes32 /*_sender*/) public view virtual returns (uint64 nonce) {\n        return 0;\n    }\n\n    /**\n     * @dev Entry point for receiving messages or packets from the endpoint.\n     * @param _origin The origin information containing the source endpoint and sender address.\n     *  - srcEid: The source chain endpoint ID.\n     *  - sender: The sender address on the src chain.\n     *  - nonce: The nonce of the message.\n     * @param _guid The unique identifier for the received LayerZero message.\n     * @param _message The payload of the received message.\n     * @param _executor The address of the executor for the received message.\n     * @param _extraData Additional arbitrary data provided by the corresponding executor.\n     *\n     * @dev Entry point for receiving msg/packet from the LayerZero endpoint.\n     */\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) public payable virtual {\n        // Ensures that only the endpoint can attempt to lzReceive() messages to this OApp.\n        if (address(endpoint) != msg.sender) revert OnlyEndpoint(msg.sender);\n\n        // Ensure that the sender matches the expected peer for the source endpoint.\n        if (_getPeerOrRevert(_origin.srcEid) != _origin.sender) revert OnlyPeer(_origin.srcEid, _origin.sender);\n\n        // Call the internal OApp implementation of lzReceive.\n        _lzReceive(_origin, _guid, _message, _executor, _extraData);\n    }\n\n    /**\n     * @dev Internal function to implement lzReceive logic without needing to copy the basic parameter validation.\n     */\n    function _lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) internal virtual;\n}\n"
    },
    "@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.20;\n\nimport { SafeERC20, IERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport { OAppCore } from \"./OAppCore.sol\";\n\n/**\n * @title OAppSender\n * @dev Abstract contract implementing the OAppSender functionality for sending messages to a LayerZero endpoint.\n */\nabstract contract OAppSender is OAppCore {\n    using SafeERC20 for IERC20;\n\n    // Custom error messages\n    error NotEnoughNative(uint256 msgValue);\n    error LzTokenUnavailable();\n\n    // @dev The version of the OAppSender implementation.\n    // @dev Version is bumped when changes are made to this contract.\n    uint64 internal constant SENDER_VERSION = 1;\n\n    /**\n     * @notice Retrieves the OApp version information.\n     * @return senderVersion The version of the OAppSender.sol contract.\n     * @return receiverVersion The version of the OAppReceiver.sol contract.\n     *\n     * @dev Providing 0 as the default for OAppReceiver version. Indicates that the OAppReceiver is not implemented.\n     * ie. this is a SEND only OApp.\n     * @dev If the OApp uses both OAppSender and OAppReceiver, then this needs to be override returning the correct versions\n     */\n    function oAppVersion() public view virtual returns (uint64 senderVersion, uint64 receiverVersion) {\n        return (SENDER_VERSION, 0);\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.quote() for fee calculation.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _payInLzToken Flag indicating whether to pay the fee in LZ tokens.\n     * @return fee The calculated MessagingFee for the message.\n     *      - nativeFee: The native fee for the message.\n     *      - lzTokenFee: The LZ token fee for the message.\n     */\n    function _quote(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) internal view virtual returns (MessagingFee memory fee) {\n        return\n            endpoint.quote(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _payInLzToken),\n                address(this)\n            );\n    }\n\n    /**\n     * @dev Internal function to interact with the LayerZero EndpointV2.send() for sending a message.\n     * @param _dstEid The destination endpoint ID.\n     * @param _message The message payload.\n     * @param _options Additional options for the message.\n     * @param _fee The calculated LayerZero fee for the message.\n     *      - nativeFee: The native fee.\n     *      - lzTokenFee: The lzToken fee.\n     * @param _refundAddress The address to receive any excess fee values sent to the endpoint.\n     * @return receipt The receipt for the sent message.\n     *      - guid: The unique identifier for the sent message.\n     *      - nonce: The nonce of the sent message.\n     *      - fee: The LayerZero fee incurred for the message.\n     */\n    function _lzSend(\n        uint32 _dstEid,\n        bytes memory _message,\n        bytes memory _options,\n        MessagingFee memory _fee,\n        address _refundAddress\n    ) internal virtual returns (MessagingReceipt memory receipt) {\n        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.\n        uint256 messageValue = _payNative(_fee.nativeFee);\n        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);\n\n        return\n            // solhint-disable-next-line check-send-result\n            endpoint.send{ value: messageValue }(\n                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),\n                _refundAddress\n            );\n    }\n\n    /**\n     * @dev Internal function to pay the native fee associated with the message.\n     * @param _nativeFee The native fee to be paid.\n     * @return nativeFee The amount of native currency paid.\n     *\n     * @dev If the OApp needs to initiate MULTIPLE LayerZero messages in a single transaction,\n     * this will need to be overridden because msg.value would contain multiple lzFees.\n     * @dev Should be overridden in the event the LayerZero endpoint requires a different native currency.\n     * @dev Some EVMs use an ERC20 as a method for paying transactions/gasFees.\n     * @dev The endpoint is EITHER/OR, ie. it will NOT support both types of native payment at a time.\n     */\n    function _payNative(uint256 _nativeFee) internal virtual returns (uint256 nativeFee) {\n        if (msg.value != _nativeFee) revert NotEnoughNative(msg.value);\n        return _nativeFee;\n    }\n\n    /**\n     * @dev Internal function to pay the LZ token fee associated with the message.\n     * @param _lzTokenFee The LZ token fee to be paid.\n     *\n     * @dev If the caller is trying to pay in the specified lzToken, then the lzTokenFee is passed to the endpoint.\n     * @dev Any excess sent, is passed back to the specified _refundAddress in the _lzSend().\n     */\n    function _payLzToken(uint256 _lzTokenFee) internal virtual {\n        // @dev Cannot cache the token because it is not immutable in the endpoint.\n        address lzToken = endpoint.lzToken();\n        if (lzToken == address(0)) revert LzTokenUnavailable();\n\n        // Pay LZ token fee by sending tokens to the endpoint.\n        IERC20(lzToken).safeTransferFrom(msg.sender, address(endpoint), _lzTokenFee);\n    }\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { IMessageLibManager } from \"./IMessageLibManager.sol\";\nimport { IMessagingComposer } from \"./IMessagingComposer.sol\";\nimport { IMessagingChannel } from \"./IMessagingChannel.sol\";\nimport { IMessagingContext } from \"./IMessagingContext.sol\";\n\nstruct MessagingParams {\n    uint32 dstEid;\n    bytes32 receiver;\n    bytes message;\n    bytes options;\n    bool payInLzToken;\n}\n\nstruct MessagingReceipt {\n    bytes32 guid;\n    uint64 nonce;\n    MessagingFee fee;\n}\n\nstruct MessagingFee {\n    uint256 nativeFee;\n    uint256 lzTokenFee;\n}\n\nstruct Origin {\n    uint32 srcEid;\n    bytes32 sender;\n    uint64 nonce;\n}\n\ninterface ILayerZeroEndpointV2 is IMessageLibManager, IMessagingComposer, IMessagingChannel, IMessagingContext {\n    event PacketSent(bytes encodedPayload, bytes options, address sendLibrary);\n\n    event PacketVerified(Origin origin, address receiver, bytes32 payloadHash);\n\n    event PacketDelivered(Origin origin, address receiver);\n\n    event LzReceiveAlert(\n        address indexed receiver,\n        address indexed executor,\n        Origin origin,\n        bytes32 guid,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    event LzTokenSet(address token);\n\n    event DelegateSet(address sender, address delegate);\n\n    function quote(MessagingParams calldata _params, address _sender) external view returns (MessagingFee memory);\n\n    function send(\n        MessagingParams calldata _params,\n        address _refundAddress\n    ) external payable returns (MessagingReceipt memory);\n\n    function verify(Origin calldata _origin, address _receiver, bytes32 _payloadHash) external;\n\n    function verifiable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function initializable(Origin calldata _origin, address _receiver) external view returns (bool);\n\n    function lzReceive(\n        Origin calldata _origin,\n        address _receiver,\n        bytes32 _guid,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n\n    // oapp can burn messages partially by calling this function with its own business logic if messages are verified in order\n    function clear(address _oapp, Origin calldata _origin, bytes32 _guid, bytes calldata _message) external;\n\n    function setLzToken(address _lzToken) external;\n\n    function lzToken() external view returns (address);\n\n    function nativeToken() external view returns (address);\n\n    function setDelegate(address _delegate) external;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nimport { Origin } from \"./ILayerZeroEndpointV2.sol\";\n\ninterface ILayerZeroReceiver {\n    function allowInitializePath(Origin calldata _origin) external view returns (bool);\n\n    function nextNonce(uint32 _eid, bytes32 _sender) external view returns (uint64);\n\n    function lzReceive(\n        Origin calldata _origin,\n        bytes32 _guid,\n        bytes calldata _message,\n        address _executor,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessageLibManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\nstruct SetConfigParam {\n    uint32 eid;\n    uint32 configType;\n    bytes config;\n}\n\ninterface IMessageLibManager {\n    struct Timeout {\n        address lib;\n        uint256 expiry;\n    }\n\n    event LibraryRegistered(address newLib);\n    event DefaultSendLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibrarySet(uint32 eid, address newLib);\n    event DefaultReceiveLibraryTimeoutSet(uint32 eid, address oldLib, uint256 expiry);\n    event SendLibrarySet(address sender, uint32 eid, address newLib);\n    event ReceiveLibrarySet(address receiver, uint32 eid, address newLib);\n    event ReceiveLibraryTimeoutSet(address receiver, uint32 eid, address oldLib, uint256 timeout);\n\n    function registerLibrary(address _lib) external;\n\n    function isRegisteredLibrary(address _lib) external view returns (bool);\n\n    function getRegisteredLibraries() external view returns (address[] memory);\n\n    function setDefaultSendLibrary(uint32 _eid, address _newLib) external;\n\n    function defaultSendLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibrary(uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function defaultReceiveLibrary(uint32 _eid) external view returns (address);\n\n    function setDefaultReceiveLibraryTimeout(uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function defaultReceiveLibraryTimeout(uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function isSupportedEid(uint32 _eid) external view returns (bool);\n\n    function isValidReceiveLibrary(address _receiver, uint32 _eid, address _lib) external view returns (bool);\n\n    /// ------------------- OApp interfaces -------------------\n    function setSendLibrary(address _oapp, uint32 _eid, address _newLib) external;\n\n    function getSendLibrary(address _sender, uint32 _eid) external view returns (address lib);\n\n    function isDefaultSendLibrary(address _sender, uint32 _eid) external view returns (bool);\n\n    function setReceiveLibrary(address _oapp, uint32 _eid, address _newLib, uint256 _gracePeriod) external;\n\n    function getReceiveLibrary(address _receiver, uint32 _eid) external view returns (address lib, bool isDefault);\n\n    function setReceiveLibraryTimeout(address _oapp, uint32 _eid, address _lib, uint256 _expiry) external;\n\n    function receiveLibraryTimeout(address _receiver, uint32 _eid) external view returns (address lib, uint256 expiry);\n\n    function setConfig(address _oapp, address _lib, SetConfigParam[] calldata _params) external;\n\n    function getConfig(\n        address _oapp,\n        address _lib,\n        uint32 _eid,\n        uint32 _configType\n    ) external view returns (bytes memory config);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingChannel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingChannel {\n    event InboundNonceSkipped(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce);\n    event PacketNilified(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n    event PacketBurnt(uint32 srcEid, bytes32 sender, address receiver, uint64 nonce, bytes32 payloadHash);\n\n    function eid() external view returns (uint32);\n\n    // this is an emergency function if a message cannot be verified for some reasons\n    // required to provide _nextNonce to avoid race condition\n    function skip(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce) external;\n\n    function nilify(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function burn(address _oapp, uint32 _srcEid, bytes32 _sender, uint64 _nonce, bytes32 _payloadHash) external;\n\n    function nextGuid(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (bytes32);\n\n    function inboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n\n    function outboundNonce(address _sender, uint32 _dstEid, bytes32 _receiver) external view returns (uint64);\n\n    function inboundPayloadHash(\n        address _receiver,\n        uint32 _srcEid,\n        bytes32 _sender,\n        uint64 _nonce\n    ) external view returns (bytes32);\n\n    function lazyInboundNonce(address _receiver, uint32 _srcEid, bytes32 _sender) external view returns (uint64);\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingComposer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingComposer {\n    event ComposeSent(address from, address to, bytes32 guid, uint16 index, bytes message);\n    event ComposeDelivered(address from, address to, bytes32 guid, uint16 index);\n    event LzComposeAlert(\n        address indexed from,\n        address indexed to,\n        address indexed executor,\n        bytes32 guid,\n        uint16 index,\n        uint256 gas,\n        uint256 value,\n        bytes message,\n        bytes extraData,\n        bytes reason\n    );\n\n    function composeQueue(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index\n    ) external view returns (bytes32 messageHash);\n\n    function sendCompose(address _to, bytes32 _guid, uint16 _index, bytes calldata _message) external;\n\n    function lzCompose(\n        address _from,\n        address _to,\n        bytes32 _guid,\n        uint16 _index,\n        bytes calldata _message,\n        bytes calldata _extraData\n    ) external payable;\n}\n"
    },
    "@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/IMessagingContext.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\ninterface IMessagingContext {\n    function isSendingMessage() external view returns (bool);\n\n    function getSendContext() external view returns (uint32 dstEid, address sender);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/DataAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { OApp, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LiquidityManager } from \"./LiquidityManager.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport { IFlareContractRegistry } from \"@flarenetwork/flare-periphery-contracts/coston2/util-contracts/userInterfaces/IFlareContractRegistry.sol\";\nimport { IFastUpdater } from \"@flarenetwork/flare-periphery-contracts/coston2/ftso/userInterfaces/IFastUpdater.sol\";\nimport { IDataProvider, Data, DataTypes } from \"./IDataProvider.sol\";\n\nuint32 constant CALLBACK_GAS_LIMIT = 4_000_000;\n\nstruct TokenInfo {\n\tstring _name;\n\taddress _address;\n\tuint32 _chainId;\n\tuint32 _id;\n}\n\nstruct IndexUpdateMessage {\n\tData[] liquidityMessages;\n\tData[] supplyMessages;\n\tData[] priceMessages;\n}\n\nstruct AggregatorParams {\n\tuint256 _timeWindow;\n\tuint256 _sampleSize;\n\tuint256 _bribeUnit;\n}\n\nerror NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\n\ncontract DataAggregator is OApp {\n\tTokenInfo[] public tokenInfo;\n\tIDataProvider[] public dataProviders;\n\tTokenInfo[] tmpTokens;\n\tmapping(string => uint256) public tokens;\n\tstring[] public tokenSymbols;\n\n\tuint256[] public totalSupplies;\n\tuint256[] public liquidities;\n\tuint256[] public prices;\n\tuint256[] public tokenParamsTimestampUpdates;\n\tData[] public messages;\n\tData[] public supplyMessages;\n\tData[] public liquidityMessages;\n\tData[] public priceMessages;\n\n\n\n\tmapping(uint256 => uint256[]) public movingAverage;\n\tuint256 sampleSize;\n\tuint256 timeWindow;\n\tuint256 samplingFrequency;\n\tuint256 lastSampleTime;\n\tuint256[] public lastIndexOrder;\n\tmapping(string => uint256[]) public tagsIndexOrder;\n\tmapping(string => uint256) public tagsIndexTimestamp;\n\tuint256 public lastIndexTimestamp;\n\tuint256 public bribeUnit;\n\tuint32 public chainId;\n\tuint32 public mainChainId;\n\n\tconstructor(\n\t\tTokenInfo[] memory _tokenInfo,\n\t\taddress _endpoint,\n\t\taddress[] memory _dataProviders,\n\t\tAggregatorParams memory _aggregatorParams\n\t) OApp(_endpoint, msg.sender) {\n\t\tsampleSize = _aggregatorParams._sampleSize;\n\t\ttimeWindow = _aggregatorParams._timeWindow;\n\t\tsamplingFrequency = timeWindow / sampleSize;\n\t\tbribeUnit = _aggregatorParams._bribeUnit;\n\n\t\tfor (uint256 i = 0; i < _dataProviders.length; i++) {\n\t\t\tdataProviders.push(IDataProvider(_dataProviders[i]));\n\t\t}\n\n\t\tfor (uint256 i = 0; i < _tokenInfo.length; i++) {\n\t\t\ttokenInfo.push(_tokenInfo[i]);\n\t\t\t// tokenSymbols.push(_tokenInfo[i]._symbol);\n\t\t\ttokens[_tokenInfo[i]._name] = _tokenInfo[i]._id;\n\t\t}\n\n\t\tprices = new uint256[](tokenInfo.length);\n\t\ttotalSupplies = new uint256[](tokenInfo.length);\n\t\tliquidities = new uint256[](tokenInfo.length);\n\t\ttokenParamsTimestampUpdates = new uint256[](tokenInfo.length);\n\t}\n\n\tfunction isMainChain() public view returns (bool) {\n\t\treturn chainId == mainChainId;\n\t}\n\n\tfunction isOnSameChain(uint32 _chainId) public view returns (bool) {\n\t\treturn chainId == _chainId;\n\t}\n\n\tfunction setChainId(uint32 _chainId, uint32 _mainChainId) external {\n\t\tchainId = _chainId;\n\t\tmainChainId = _mainChainId;\n\t}\n\n\tfunction updateTokenParams(\n\t\tuint256[] memory _totalSupplies,\n\t\tuint256[] memory _liquidities\n\t) external {\n\t\tfor (uint256 i = 0; i < dataProviders.length; i++) {\n\t\t\tDataTypes dataType = dataProviders[i].getDataType();\n\t\t\tif (dataType == DataTypes.PRICE) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\tprices[tokens[dataProviders[i].getLabel()]] = dataProviders[\n\t\t\t\t\t\ti\n\t\t\t\t\t].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dataType == DataTypes.TOTAL_SUPPLY) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\ttotalSupplies[\n\t\t\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t\t\t] = dataProviders[i].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dataType == DataTypes.LIQUIDITY) {\n\t\t\t\tif (isOnSameChain(dataProviders[i].getChainId())) {\n\t\t\t\t\tliquidities[\n\t\t\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t\t\t] = dataProviders[i].getMetricData();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttokenParamsTimestampUpdates[\n\t\t\t\ttokens[dataProviders[i].getLabel()]\n\t\t\t] = dataProviders[i].getDataTimestamp();\n\t\t}\n\n\t\t// DATA MESSAGES\n\t\tif (isMainChain()) {\n\t\t\t// RECEIVED\n\t\t\tfor (uint256 i = 0; i < messages.length; i++) {\n\t\t\t\tif (messages[i].dataType == DataTypes.PRICE) {\n\t\t\t\t\tprices[tokens[messages[i].label]] = messages[i].metricData;\n\t\t\t\t}\n\t\t\t\tif (messages[i].dataType == DataTypes.TOTAL_SUPPLY) {\n\t\t\t\t\ttotalSupplies[tokens[messages[i].label]] = messages[i]\n\t\t\t\t\t\t.metricData;\n\t\t\t\t}\n\t\t\t\tif (messages[i].dataType == DataTypes.LIQUIDITY) {\n\t\t\t\t\tliquidities[tokens[messages[i].label]] = messages[i]\n\t\t\t\t\t\t.metricData;\n\t\t\t\t}\n\t\t\t\ttokenParamsTimestampUpdates.push(messages[i].dataTimestamp);\n\t\t\t}\n\t\t}\n\n\t\tif (!isMainChain()) {\n\t\t\t// SEND \n\t\t\tData[] memory _supplyMessages = new Data[](tokenInfo.length);\n\t\t\tData[] memory _liquidityMessages = new Data[](tokenInfo.length);\n\n\t\t\tData[] memory _priceMessages = new Data[](tokenInfo.length);\n\n\t\t\tfor (uint256 i = 0; i < tokenInfo.length; i++) {\n\t\t\t\tif (chainId == tokenInfo[i]._chainId) {\n\t\t\t\t\t_supplyMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\t_totalSupplies[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.TOTAL_SUPPLY,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t\t_liquidityMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\t_liquidities[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.LIQUIDITY,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t\t_priceMessages[i] = Data(\n\t\t\t\t\t\ttokenInfo[i]._name,\n\t\t\t\t\t\ttokenInfo[i]._address,\n\t\t\t\t\t\tprices[i],\n\t\t\t\t\t\tblock.timestamp,\n\t\t\t\t\t\tDataTypes.PRICE,\n\t\t\t\t\t\tchainId\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _lzReceive(\n\t\tOrigin calldata /*_origin*/,\n\t\tbytes32 /*_guid*/,\n\t\tbytes calldata payload,\n\t\taddress /*_executor*/,\n\t\tbytes calldata /*_extraData*/\n\t) internal override {\n\t\t// data = abi.decode(payload, (string));\n\t\tData[] memory _inboxMessages = abi.decode(payload, (Data[]));\n\t\tfor (uint256 i = 0; i < _inboxMessages.length; i++) {\n\t\t\tmessages.push(_inboxMessages[i]);\n\t\t}\n\t}\n\n\tfunction normalizePrice(\n\t\tuint256 price,\n\t\tint8 decimals\n\t) public pure returns (uint256) {\n\t\tint8 maxDecimals = 18; // Set maximum decimals to 10\n\n\t\t// Scale the price to the maximum number of decimals\n\t\tuint256 normalizedPrice = price *\n\t\t\t(10 ** uint256(uint8(maxDecimals - decimals)));\n\n\t\treturn normalizedPrice;\n\t}\n\n\tfunction quote(\n\t\tuint32 _dstEid,\n\t\tstring memory _message,\n\t\tbytes memory _options,\n\t\tbool _payInLzToken\n\t) public view returns (MessagingFee memory fee) {\n\t\tbytes memory payload = abi.encode(_message);\n\t\tfee = _quote(_dstEid, payload, _options, _payInLzToken);\n\t}\n\n\tfunction send(\n\t\tuint32 _dstEid,\n\t\tbytes memory _options\n\t) external payable returns (MessagingReceipt memory receipt) {\n\t\tData[] memory outboxMessages = new Data[](supplyMessages.length + liquidityMessages.length + priceMessages.length);\n\t\tfor (uint256 i = 0; i < supplyMessages.length; i++) {\n\t\t\toutboxMessages[i] = supplyMessages[i];\n\t\t}\n\t\tfor (uint256 i = 0; i < liquidityMessages.length; i++) {\n\t\t\toutboxMessages[supplyMessages.length + i] = liquidityMessages[i];\n\t\t}\n\t\tfor (uint256 i = 0; i < priceMessages.length; i++) {\n\t\t\toutboxMessages[supplyMessages.length + liquidityMessages.length + i] = priceMessages[i];\n\t\t}\n\n\t\t// TO-DO: need to clean the queues\n\t\tbytes memory _payload = abi.encode(outboxMessages);\n\t\treceipt = _lzSend(\n\t\t\t_dstEid,\n\t\t\t_payload,\n\t\t\t_options,\n\t\t\tMessagingFee(msg.value, 0),\n\t\t\tpayable(msg.sender)\n\t\t);\n\t}\n}\n"
    },
    "contracts/ExampleLz.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { OApp, MessagingFee, Origin } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OApp.sol\";\nimport { MessagingReceipt } from \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppSender.sol\";\nimport { MessagingParams, MessagingFee, MessagingReceipt } from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\n\ncontract MyOApp is OApp {\n    constructor(address _endpoint) OApp(_endpoint, msg.sender) {}\n\n    string public data = \"Nothing received yet.\";\n\n    /**\n     * @notice Sends a message from the source chain to a destination chain.\n     * @param _dstEid The endpoint ID of the destination chain.\n     * @param _message The message string to be sent.\n     * @param _options Additional options for message execution.\n     * @dev Encodes the message as bytes and sends it using the `_lzSend` internal function.\n     * @return receipt A `MessagingReceipt` struct containing details of the message sent.\n     */\n    function send(\n        uint32 _dstEid,\n        string memory _message,\n        bytes calldata _options\n    ) external payable returns (MessagingReceipt memory receipt) {\n        bytes memory _payload = abi.encode(_message);\n        receipt = _lzSend(_dstEid, _payload, _options, MessagingFee(msg.value, 0), payable(msg.sender));\n    }\n\n    /**\n     * @notice Quotes the gas needed to pay for the full omnichain transaction in native gas or ZRO token.\n     * @param _dstEid Destination chain's endpoint ID.\n     * @param _message The message.\n     * @param _options Message execution options (e.g., for sending gas to destination).\n     * @param _payInLzToken Whether to return fee in ZRO token.\n     * @return fee A `MessagingFee` struct containing the calculated gas fee in either the native token or ZRO token.\n     */\n    function quote(\n        uint32 _dstEid,\n        string memory _message,\n        bytes memory _options,\n        bool _payInLzToken\n    ) public view returns (MessagingFee memory fee) {\n        bytes memory payload = abi.encode(_message);\n        // return MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), payload, _options, _payInLzToken);\n        fee = _quote(_dstEid, payload, _options, _payInLzToken);\n        // return MessagingFee(0, 10);\n    }\n\n    /**\n     * @dev Internal function override to handle incoming messages from another chain.\n     * @dev _origin A struct containing information about the message sender.\n     * @dev _guid A unique global packet identifier for the message.\n     * @param payload The encoded message payload being received.\n     *\n     * @dev The following params are unused in the current implementation of the OApp.\n     * @dev _executor The address of the Executor responsible for processing the message.\n     * @dev _extraData Arbitrary data appended by the Executor to the message.\n     *\n     * Decodes the received payload and processes it as per the business logic defined in the function.\n     */\n    function _lzReceive(\n        Origin calldata /*_origin*/,\n        bytes32 /*_guid*/,\n        bytes calldata payload,\n        address /*_executor*/,\n        bytes calldata /*_extraData*/\n    ) internal override {\n        data = abi.decode(payload, (string));\n    }\n}\n"
    },
    "contracts/IDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\ninterface IDataProvider {\n\tfunction getLabel() external view returns (string memory);\n\n\tfunction getMetricData() external view returns (uint256);\n\n\tfunction getTags() external view returns (string[] memory);\n\n\tfunction getDataTimestamp() external view returns (uint256);\n\n\tfunction getDataType() external view returns (DataTypes);\n\n\tfunction getAssetAddress() external view returns (address);\n\n\tfunction getChainId() external view returns (uint32);\n}\n\nenum DataTypes {\n\tPRICE,\n\tLIQUIDITY,\n\tTOTAL_SUPPLY,\n\tCATEGORY,\n\tOTHER\n}\n\nstruct Data {\n\tstring label;\n\taddress assetAddress;\n\tuint256 metricData;\n\tuint256 dataTimestamp;\n\tDataTypes dataType;\n\tuint32 chainId;\n\n}\n"
    },
    "contracts/IndexGenerator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { DataAggregator, TokenInfo, AggregatorParams } from \"./DataAggregator.sol\";\n\ncontract IndexGenerator is DataAggregator {\n\tuint256 public indexSize;\n\n\tconstructor(\n\t\tTokenInfo[] memory _tokenInfo,\n\t\taddress _endpoint,\n\t\taddress[] memory _dataProviders,\n\t\tAggregatorParams memory _aggregatorParams,\n\t\tuint256 indexSize\n\t) DataAggregator(_tokenInfo, _endpoint, _dataProviders, _aggregatorParams) {\n\t\tindexSize = indexSize;\n\t}\n\n\tfunction persistIndex(\n\t\tuint256[] memory indexOrders,\n\t\tstring memory tag\n\t) public returns (bool) {\n\t\trequire(\n\t\t\tindexOrders.length == indexSize,\n\t\t\t\"IndexAggregator: Invalid length of indexOrders\"\n\t\t);\n\n\t\t// indexOrders is an array index order [2,0,1] means 2nd token, 0th token, 1st token for price calculation\n\n\t\t// if (\n\t\t// \tkeccak256(abi.encodePacked(tag)) != keccak256(abi.encodePacked(\"\"))\n\t\t// ) {\n\t\t// \tfor (uint256 i = 0; i < tmpTokens.length; i++) {\n\t\t// \t\tdelete tmpTokens[i];\n\t\t// \t}\n\t\t// \tfor (uint256 i = 0; i < tokenInfo.length; i++) {\n\t\t// \t\tfor (uint256 j = 0; j < tokenInfo[i]._tags.length; j++) {\n\t\t// \t\t\tif (\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tokenInfo[i]._tags[j])) ==\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tag))\n\t\t// \t\t\t) {\n\t\t// \t\t\t\t// need to check if the tag was verified on the tagging system\n\t\t// \t\t\t\t// require(\n\t\t// \t\t\t\t//     taggingVerifier.tokenSymbolToVerifiedTagsMap(tokenInfo[i]._symbol, tag) == true,\n\t\t// \t\t\t\t//     \"IndexAggregator: Tag not verified\"\n\t\t// \t\t\t\t// );\n\t\t// \t\t\t\ttmpTokens.push(tokenInfo[i]);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \trequire(\n\t\t// \t\ttmpTokens.length == indexOrders.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of token with required tags\"\n\t\t// \t);\n\t\t// } else {\n\t\t// \trequire(\n\t\t// \t\tindexOrders.length == tokenInfo.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of indexOrders\"\n\t\t// \t);\n\t\t// }\n\n\t\tuint256 token_a_value;\n\t\tuint256 token_b_value;\n\t\tfor (uint256 i = 0; i < indexOrders.length - 1; i++) {\n\t\t\ttoken_a_value = 0;\n\t\t\ttoken_b_value = 0;\n\n\t\t\tfor (uint256 j = 0; j < movingAverage[indexOrders[i]].length; j++) {\n\t\t\t\ttoken_a_value +=\n\t\t\t\t\tmovingAverage[indexOrders[i]][j] *\n\t\t\t\t\ttotalSupplies[indexOrders[i]];\n\t\t\t\ttoken_b_value +=\n\t\t\t\t\tmovingAverage[indexOrders[i + 1]][j] *\n\t\t\t\t\ttotalSupplies[indexOrders[i + 1]];\n\t\t\t}\n\n\t\t\trequire(token_a_value > 0, \"IndexAggregator: Token value is zero\");\n\t\t\trequire(token_b_value > 0, \"IndexAggregator: Token value is zero\");\n\t\t\trequire(\n\t\t\t\ttoken_a_value > token_b_value,\n\t\t\t\t\"IndexAggregator: order is not correct\"\n\t\t\t);\n\t\t}\n\n\t\tlastIndexOrder = indexOrders;\n\t\tlastIndexTimestamp = block.timestamp;\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/IndexGeneratorV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { DataAggregator, TokenInfo, AggregatorParams } from \"./DataAggregator.sol\";\n\ncontract IndexGeneratorV2 {\n\tuint256 public indexSize;\n\tuint256 public counter = 0;\n\n\tconstructor() {}\n\n\tfunction colleectBribes() public returns (bool) {\n\t\tcounter++;\n\t\treturn true;\n\t}\n\n\tfunction updateTokenParams(\n\t\tTokenInfo[] memory _tokenInfo,\n\t\taddress _endpoint,\n\t\taddress[] memory _dataProviders,\n\t\tAggregatorParams memory _aggregatorParams,\n\t\tuint256 indexSize\n\t) public returns (bool) {\n\t\tcounter++;\n\t\treturn true;\n\t}\n\n\tfunction updateTokenPars() public returns (bool) {\n\t\tcounter++;\n\t\treturn true;\n\t}\n\n\tfunction sendMainChain() public returns (bool) {\n\t\tcounter++;\n\t\treturn true;\n\t}\n\n\tfunction persistIndex(\n\t\tuint256[] memory indexOrders,\n\t\tstring memory tag\n\t) public returns (bool) {\n\t\tcounter++;\n\n\t\t// indexOrders is an array index order [2,0,1] means 2nd token, 0th token, 1st token for price calculation\n\n\t\t// if (\n\t\t// \tkeccak256(abi.encodePacked(tag)) != keccak256(abi.encodePacked(\"\"))\n\t\t// ) {\n\t\t// \tfor (uint256 i = 0; i < tmpTokens.length; i++) {\n\t\t// \t\tdelete tmpTokens[i];\n\t\t// \t}\n\t\t// \tfor (uint256 i = 0; i < tokenInfo.length; i++) {\n\t\t// \t\tfor (uint256 j = 0; j < tokenInfo[i]._tags.length; j++) {\n\t\t// \t\t\tif (\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tokenInfo[i]._tags[j])) ==\n\t\t// \t\t\t\tkeccak256(abi.encodePacked(tag))\n\t\t// \t\t\t) {\n\t\t// \t\t\t\t// need to check if the tag was verified on the tagging system\n\t\t// \t\t\t\t// require(\n\t\t// \t\t\t\t//     taggingVerifier.tokenSymbolToVerifiedTagsMap(tokenInfo[i]._symbol, tag) == true,\n\t\t// \t\t\t\t//     \"IndexAggregator: Tag not verified\"\n\t\t// \t\t\t\t// );\n\t\t// \t\t\t\ttmpTokens.push(tokenInfo[i]);\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t}\n\t\t// \trequire(\n\t\t// \t\ttmpTokens.length == indexOrders.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of token with required tags\"\n\t\t// \t);\n\t\t// } else {\n\t\t// \trequire(\n\t\t// \t\tindexOrders.length == tokenInfo.length,\n\t\t// \t\t\"IndexAggregator: Invalid length of indexOrders\"\n\t\t// \t);\n\t\t// }\n\n\t\treturn true;\n\t}\n}\n"
    },
    "contracts/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}"
    },
    "contracts/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool{\n    function liquidity() external view returns (uint128);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}"
    },
    "contracts/LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IUniswapV3Factory.sol\";\nimport \"./IUniswapV3Pool.sol\";\n\n\ncontract LiquidityManager {\n    IUniswapV3Factory public factory;\n    uint24[] public feeTiers = [500, 3000, 10000]; // Example fee tiers: 0.05%, 0.3%, 1% these are Uniswap V3 standards\n    address[] public comparisonTokens;\n\n    constructor(address _factory, address[] memory _comparisonTokens) {\n        factory = IUniswapV3Factory(_factory);\n        comparisonTokens = _comparisonTokens;\n    }\n\n    function getPoolsForToken(address token) public view returns (address[] memory) {\n        uint256 poolCount = 0;\n        address[] memory tempPools = new address[](comparisonTokens.length * feeTiers.length);\n\n        for (uint256 i = 0; i < comparisonTokens.length; i++) {\n            if (comparisonTokens[i] == token) continue;\n            for (uint256 j = 0; j < feeTiers.length; j++) {\n                address pool = factory.getPool(token, comparisonTokens[i], feeTiers[j]);\n                if (pool != address(0)) {\n                    tempPools[poolCount] = pool;\n                    poolCount++;\n                }\n            }\n        }\n\n        // Create an array of the actual size\n        address[] memory pools = new address[](poolCount);\n        for (uint256 i = 0; i < poolCount; i++) {\n            pools[i] = tempPools[i];\n        }\n\n        return pools;\n    }\n\n    function getTotalLiquidityForToken(address token) public view returns (uint256 totalLiquidity) {\n        address[] memory pools = getPoolsForToken(token);\n        for (uint256 i = 0; i < pools.length; i++) {\n            totalLiquidity += 1;\n            IUniswapV3Pool(pools[i]).liquidity();\n        }\n        return totalLiquidity;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}